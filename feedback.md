# Assignment Two Feedback

## Group members: u6275198,u6528982,u6162630

## Tutor Comment
Well done!! A nice multiplayer game;)
Interesting way to play the game, though it's a little bit difficult to play
Supporters not displayed
Only 1 AI player and option
Good OO features demonstrated, code can be more concise by finding the pattern and eliminating repetitive code
Would be better if provide authorship and javadoc on each class created
Extensions: background music(although it turned back on after turned off(?)), game instruction
Very interesting theme;)

## Mark

**  9.4/11.0**

## Miscellaneous marks

| Level | Requirement | Result |
|:-:|---|:-:|
||All files correct                     | .25/.25 |
||Authorship clear for all classes      | /.25 |
||Appropriate use of git                | .5/.5  |
||Program runs from jar                 | .25/.25 |
|P|Appropriate use of OO features       | .5/.5  |
|P|Presentation pdf complete            | .5/.5  |
|CR|Program well designed               | .5/.5  |
|CR|Comments clear and sufficient       | .4/.5  |
|CR|Coding style good                   | .25/.25 |
|CR|Appropriate use of JUnit tests      | .5/.5  |
|D|Design and code of very high quality | /.25 |
|D|Demonstrates interesting extensions  | .25/.25 |
|D|Works well and easy to run           | .2/.25 |
|HD|Game is exceptional                 | /.5  |

**Total for miscellaneous marks:**  4.1/5.25

## Game marks (manual)

| Level | Requirement | Result |
|:-:|---|:-:|
|CR|Game can be played by 2-4 humans | .25/.25 |
|CR|Only valid moves allowed         | .25/.25 |
|CR|Flags and supporters displayed   | .15/.25 |
|CR|End of game indicates winner     | .25/.25 |
|D |Basic computer opponent          | .25/.25 |
|HD|Advanced computer opponent       | .15/.5  |

**Total for manual marks:** 1.3/1.75

## Test results

| Task | Test | Result | Marks |
|:-:|---|:-:|:-:|
| |Compiled|.25/.25|.25|
|2|CardPlacementWellFormed|5/5|.5|
|3|PlacementWellFormed|5/5|.5|
|5|MoveLegal|5/5|.5|
|6|MoveSequenceValid|5/5|1|
|7|GetSupporters|3/3|.375|
|8|GetFlags|3/3|.375|
|10|GenerateMove|3/3|.5|

**Total for tests:** 4.00/4.0

## Originality statements

#### Originality statement G
We declare that the work we have submitted for Stage G of this assignment and all stages before it is entirely our own work, with the following documented exceptions:

* Some code was referenced from stackoverflow, but the idea behind the implementation itself, was original.
* Images have been picked up and modified from free images available on google.

Signed: John Rufus Raja (u6275198), Jiajia Xu (u6528982), and Songtuan Lin (u6162630)

#### Originality statement F
We declare that the work we have submitted for Stage F of this assignment and all stages before it is entirely our own work, with the following documented exceptions:

no exceptions.

Signed: Jiajia Xu (u6528982), Songtuan Lin (u6162630), and John Rufus Raja(u6275198)

#### Originality statements E
I declare that the work I have submitted for Stage E of this assignment and all stages before it is entirely my own work, with the
following documented exceptions:

No Exceptions.

Signed: Songtuan Lin (u6162630)
I declare that the work I have submitted for Stage E of this assignment and all stages before it is entirely my own work, with the
following documented exceptions:

No Exceptions.

Signed: John Rufus Raja (u6275198)
I declare that the work I have submitted for Stage E of this assignment and all stages before it is entirely my own work, with the
following documented exceptions:

No Exceptions.

Signed: Jiajia Xu (u6528982)

#### Originality statements D
I declare that the work I have submitted for Stage D of this assignment and all stages before it is entirely my own work, with the following documented exceptions:

* The idea of <...> came from a discussion with <...>

* The code in class <...> uses an idea suggested by <...>

Signed: Songtuan Lin (u6162630)
I declare that the work I have submitted for Stage D of this assignment and all stages before it is entirely my own work, with the following documented exceptions:

*The objective was discussed with teammates for task 10, but implementation is original.

Signed: John Rufus Raja (u6275198)
I declare that the work I have submitted for Stage D of this assignment and all stages before it is entirely my own work, with the following documented exceptions:


Signed: Jiajia  Xu (u6528982)

#### Originality statement C
We declare that the work we have submitted for Stage C of this assignment and all stages before it is entirely our own work, with the following documented exceptions:

1. The objective for task 4 was discussed, however, the implementation was done without support. The concept of GridPanes was taken from stackoverflow.

Signed: Jiajia Xu (u6528982), Songtuan Lin (u6162630), and John Rufus Raja(u6275198)

#### Originality statement B
We declare that the work we have submitted for Stage B of this assignment and all stages before it is entirely our own work, with the following documented exceptions:

No exceptions, results based on discussions and efforts within the team.

Signed: Jiajia Xu (u6528982), Songtuan Lin (u6162630), and John Rufus Raja(u6275198)

## Git Log
```
commit 95bbd06b3edd0b36818272936794308b5d24a1ef
Merge: d3d9802 9e4d78d
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Fri May 18 03:22:04 2018 +1000

    Merge remote-tracking branch 'origin/master'

commit d3d9802072231aba18435a2bced7bef903016975
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Fri May 18 03:21:53 2018 +1000

    Updated various pieces of code/images to match the layout. and updated the presentation.

commit 9e4d78d1e9c4365511a3e60499738e412778fbb6
Author: Songtuan Lin <u6162630@anu.edu.au>
Date:   Fri May 18 02:05:38 2018 +1000

    best code statement

commit ac5a8401ffea3af1c6e8dde6baf29f51c027d492
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Fri May 18 01:54:31 2018 +1000

    Best code updated - Rufus

commit 3bbdb1b11a851285a313e7f5bdf944cba45ea4e2
Merge: 4bd998b f3a9e4d
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Fri May 18 01:45:51 2018 +1000

    Merge remote-tracking branch 'origin/master'

commit 4bd998bf1be8fe6b1932ec7f8646b82464dcb380
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Fri May 18 01:45:20 2018 +1000

    Best code updated - Rufus

commit f3a9e4db591535145ccb15298b520436b52d751f
Author: xujiajia <u6528982@anu.edu.au>
Date:   Fri May 18 01:35:06 2018 +1000

    game jar

commit e0e884518e882aedc93f7bcc5111297f5b42a686
Merge: 12161a1 21b1a6d
Author: xujiajia <u6528982@anu.edu.au>
Date:   Fri May 18 01:23:41 2018 +1000

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/u6275198/comp1110-ass2-wed18c

commit 21b1a6d2a4b7a0f64ca489ce349cb0b7b058928e
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Fri May 18 01:17:57 2018 +1000

    Cleaned some code.

commit 12161a163c34fc816f776da1315d2206eb99dd8f
Merge: a5b9e70 1523f97
Author: xujiajia <u6528982@anu.edu.au>
Date:   Fri May 18 01:11:22 2018 +1000

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/u6275198/comp1110-ass2-wed18c

commit 1523f97e243763c76fb85a6b1ee0d54da1943ebe
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Fri May 18 01:09:38 2018 +1000

    presentation added - Rufus, Jiajia

commit a5b9e702f78d1dec8e739641956ebc2583f1a036
Author: xujiajia <u6528982@anu.edu.au>
Date:   Fri May 18 00:43:30 2018 +1000

    best code statement

commit f60a0a2804ae171443e5c4407605ba3a6a1c9038
Merge: 0d102d3 78ca5e1
Author: Garrick <lst19941027@gmail.com>
Date:   Thu May 17 23:45:04 2018 +1000

    Merge remote-tracking branch 'origin/master'
    
    # Conflicts:
    #       src/comp1110/ass2/gui/Game.java

commit 0d102d3908a470b339ca50c47e351c5d0bcccc9d
Author: Garrick <lst19941027@gmail.com>
Date:   Thu May 17 23:35:02 2018 +1000

    AI modified

commit 78ca5e13648587033141235de664f7df605cc467
Merge: 4b3e02d cbdccda
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 22:32:42 2018 +1000

    Merge remote-tracking branch 'origin/master'

commit 4b3e02d02ab670ee6ff94cd1fcc469abccb0e28f
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 22:32:09 2018 +1000

    presentation added - Rufus, Jiajia

commit cbdccdada7b8c78b7f83fd8a5c445d32db45df0b
Merge: 6ca43ba d9a7a5e
Author: xujiajia <u6528982@anu.edu.au>
Date:   Thu May 17 21:52:04 2018 +1000

    Merge remote-tracking branch 'origin/master'

commit 6ca43ba19ba9db22a638093a349c962af0e06392
Author: xujiajia <u6528982@anu.edu.au>
Date:   Thu May 17 21:51:42 2018 +1000

    best code statement

commit d9a7a5e89b4d18f5b94f4fcaf5cae6ea403e9788
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 21:43:32 2018 +1000

    G-Contribution - names updated

commit 5984d84f67ffe722023beebc03bc8bf246246763
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 21:42:17 2018 +1000

    G-Originality and Contribution updated

commit 0c239dceb367d2465bfa1cec277e4fbccd8efed1
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 21:36:00 2018 +1000

    G-Features updated

commit 67c1f767be780004ab1746fde1e38871a7c47600
Author: xujiajia <u6528982@anu.edu.au>
Date:   Thu May 17 21:15:38 2018 +1000

    jar file created

commit 39418893d30430fe9516db8df53103f57c09b959
Author: xujiajia <u6528982@anu.edu.au>
Date:   Thu May 17 21:07:52 2018 +1000

    ok

commit 34d17b7b1a15e914c87f208aab0668058f1f2282
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 21:05:56 2018 +1000

    Commented code removed and code cleaned

commit 9db4ae543d34719279ad02ddc5af25159a8a9358
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 20:42:40 2018 +1000

    Commented code removed and code cleaned

commit cc0e5126387a4f9d0aff5ba81768f6a1c88ae755
Merge: 803cfbc 783c938
Author: xujiajia <u6528982@anu.edu.au>
Date:   Thu May 17 17:43:23 2018 +1000

    Merge remote-tracking branch 'origin/master'
    
    # Conflicts:
    #       src/comp1110/ass2/gui/Game.java

commit 803cfbca8b54d9cfcdda5a0b82c499e9b6b1566b
Author: xujiajia <u6528982@anu.edu.au>
Date:   Thu May 17 17:40:37 2018 +1000

    stage F

commit 783c938d5cbd50dffbe47ba791e4a5576ba20cda
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 17:40:01 2018 +1000

    Comments removed and code cleaned

commit cf25d0aad23296880db9abf7b5c305268d44c7d7
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 17:34:07 2018 +1000

    GUI changes made

commit 691f9cb8b63764d9ab34bef4d399a09e6d7d9125
Merge: 5b0b1ab 9ba08b3
Author: Garrick <lst19941027@gmail.com>
Date:   Thu May 17 17:33:53 2018 +1000

    Merge remote-tracking branch 'origin/master'

commit 5b0b1ab83e72e9caff5e42140c8bd4bd0f34cb30
Author: Garrick <lst19941027@gmail.com>
Date:   Thu May 17 17:33:37 2018 +1000

    AI modified

commit 8e92808ecd0ee9c6ca8dacfa67873a1d97b1de55
Merge: f9615e8 9ba08b3
Author: xujiajia <u6528982@anu.edu.au>
Date:   Thu May 17 17:26:11 2018 +1000

    Merge remote-tracking branch 'origin/master'
    
    # Conflicts:
    #       src/comp1110/ass2/gui/Game.java

commit f9615e808f9797554519a1cc29ab920174956ffa
Author: xujiajia <u6528982@anu.edu.au>
Date:   Thu May 17 17:24:06 2018 +1000

    stage F

commit 9ba08b3b0b8bcf8ee68985eed8e602c9005e261c
Merge: 13eb1a3 2a50d21
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 17:21:42 2018 +1000

    Merge remote-tracking branch 'origin/master'

commit 13eb1a3798f900687245fc79cf0eedcecdc37fce
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 17:21:34 2018 +1000

    GUI changes made

commit 2a50d21d4b14cd8d96ef1cfc89f35c7547e66a0c
Merge: 62ddb80 95dc9d0
Author: Garrick <lst19941027@gmail.com>
Date:   Thu May 17 16:49:01 2018 +1000

    Merge remote-tracking branch 'origin/master'

commit 62ddb8098d17c56efee62f4c3572d6edf28c9b6d
Author: Garrick <lst19941027@gmail.com>
Date:   Thu May 17 16:48:45 2018 +1000

    AI modified

commit 95dc9d0ec04947431aa6330491b1c5c81ab63d81
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 16:00:54 2018 +1000

    GUI changes made

commit 55f6627aaace2ca2e26d628c6b714fd3b73fda3d
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 15:04:54 2018 +1000

    GUI changes made

commit a0601ca97e626914793f11410e882ae2c4c5dd0f
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 01:14:12 2018 +1000

    GUI changes made

commit 5c9eb86bcb15afd6c98130c5605cd31910edcd89
Merge: f3df0ed f9056d8
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 01:08:58 2018 +1000

    Merge remote-tracking branch 'origin/master'
    
    # Conflicts:
    #       src/comp1110/ass2/gui/Game.java

commit f3df0ed49c94582456095f0f20d1709202d269ad
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Thu May 17 01:03:10 2018 +1000

    GUI changes made

commit f9056d84f59df9c08f4bea43618ecb19fdfe4fbf
Author: Songtuan Lin <u6162630@anu.edu.au>
Date:   Thu May 17 00:38:22 2018 +1000

    AI with alpha_beta searth and simple evaluation function

commit a2909545d158ea13dfcc075350b81f1f0f623d0e
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Wed May 16 01:47:12 2018 +1000

    Task 12 in-progress

commit a6b20c6e9b86343bdd4c2add9dd7cc29bca4900b
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Tue May 15 23:22:27 2018 +1000

    GUI Changes

commit 5f16de465ed3ddea25777fdba22a1ebd8f8c6c83
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Tue May 15 14:46:05 2018 +1000

    GUI Changes

commit 6f3677293487d21a8e9561670b80e1b2b9cd48c2
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Tue May 15 13:32:12 2018 +1000

    Content added

commit 5e1280bbce81b77b31b0bef4825ada2104b6aeab
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Tue May 15 13:31:35 2018 +1000

    Gui Changes made

commit 897a1f08e411d3db2bde8f4dd59c431f19268930
Merge: adae5aa 2033226
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Tue May 15 12:31:36 2018 +1000

    Merge remote-tracking branch 'origin/master'

commit 20332265f0582ea559447a61fc2a8f78409f746d
Merge: 39534cf e475f3d
Author: Garrick <lst19941027@gmail.com>
Date:   Mon May 14 16:21:25 2018 +1000

    Merge remote-tracking branch 'origin/master'

commit 39534cff7423483124f8913317ba4b2825e454ba
Author: Garrick <lst19941027@gmail.com>
Date:   Mon May 14 16:21:09 2018 +1000

    Task 9 help method

commit e475f3d748f0a512d3ff4e6d399e0d0c32a41164
Author: xujiajia <u6528982@anu.edu.au>
Date:   Mon May 14 14:25:19 2018 +1000

    task11

commit adae5aaa035714872a7bac93ed19afce0e08df5d
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Mon May 14 13:49:34 2018 +1000

    Task 9 - Jiajia, Songtuan, Rufus

commit dc076d0c0cb2758e7c5788b8aca2f821b249e864
Author: Rufus <u6275198@anu.edu.au>
Date:   Sat May 12 19:38:10 2018 +1000

    Task 9 completed

commit d754efb3d992bacf0a6715a6c9f7cafd4cd66c43
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Sat May 12 15:41:23 2018 +1000

    Task 9 - Jiajia, Songtuan, Rufus

commit a0e02df248f86a0d30a07898d68fdf6c84d96876
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Sat May 12 13:00:08 2018 +1000

    Task 9 - Jiajia, Songtuan, Rufus

commit 5d74bbe307edc387591e4c5cfbe39e43bc988c04
Author: u6275198 <u6275198@anu.edu.au>
Date:   Wed May 9 17:54:27 2018 +1000

    Jar file created. Task 9 in progress

commit d60c035bbcaef3ad16812d262a249c5a2a13d1b3
Merge: 5dfc4bd 83a00bb
Author: xujiajia <u6528982@anu.edu.au>
Date:   Wed May 9 17:31:51 2018 +1000

    Merge remote-tracking branch 'origin/master'

commit 5dfc4bdb12d5ca05a0af02fa341c5feb4ea5644d
Author: xujiajia <u6528982@anu.edu.au>
Date:   Wed May 9 17:30:46 2018 +1000

    stage F

commit 83a00bb21fc190691cf44e56d3b57d7304a72011
Merge: d303234 60d031c
Author: u6162630 <lst19941027@gmail.com>
Date:   Wed May 9 17:21:12 2018 +1000

    Merge remote-tracking branch 'origin/master'

commit d303234aedc8337541ac3fcdcaafd8dc58238a70
Author: u6162630 <lst19941027@gmail.com>
Date:   Wed May 9 17:20:39 2018 +1000

    code review

commit 60d031ca6b2ea4e4f2d422c5cc45bb17bec362a8
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Wed May 9 17:16:03 2018 +1000

    updated the review statements

commit 9cfda52162dc4fc188c96b8879578e32a51d20aa
Merge: de17237 a7ae945
Author: u6275198 <u6275198@anu.edu.au>
Date:   Wed May 9 13:55:29 2018 +1000

    Merge remote-tracking branch 'origin/master'

commit de17237c41b4fbfcb533b8ba94817cbb279280a9
Author: u6275198 <u6275198@anu.edu.au>
Date:   Wed May 9 13:55:18 2018 +1000

    Jar file created. Task 9 in progress

commit a7ae9454a8018c69cf2f0658dcbf9b9257b4a69b
Author: Songtuan Lin <songtuan.lin@anu.edu.au>
Date:   Wed May 2 18:11:42 2018 +1000

    Add new file

commit d5520294d4d54a4433167aa43c30c856602ca2e7
Author: xujiajia <u6528982@anu.edu.au>
Date:   Wed May 2 18:07:40 2018 +1000

    junit tests

commit 0a3f616385ef9ae698cb53bb6fedbc3b3c8cdb19
Author: xujiajia <u6528982@anu.edu.au>
Date:   Wed May 2 17:52:19 2018 +1000

    junit tests

commit 623ff2122015f21c0329b68df699b60d70550195
Author: xujiajia <u6528982@anu.edu.au>
Date:   Wed May 2 17:42:31 2018 +1000

    junit tests

commit 8971e5d4582f6e69f45d1078c2f04c0d3b76bda5
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Wed May 2 17:10:47 2018 +1000

    Minor changes to corTocharTest

commit 65ef2a16806815451eec8b1309fc355f60c24bc2
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Wed May 2 17:00:04 2018 +1000

    Added comment to Card.java

commit e1e8b02a42ded697bd831f4807d3d13c4f640533
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Wed May 2 16:56:33 2018 +1000

    Minor changes to SubstrTest

commit 5fe3365fce89bc915732ab6160589b3eb048bed4
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Wed May 2 16:54:59 2018 +1000

    updated comments to the tests

commit 4b92e6260a96a7854ca156a1e75b92ddd565504c
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Wed May 2 16:47:30 2018 +1000

    Added Tests for corTochar and Substr functions

commit ee10f39d102679b9f18dbd2829a701bd5b9f9ca8
Author: Garrick <lst19941027@gmail.com>
Date:   Tue May 1 22:04:47 2018 +1000

    Comment

commit 2f5139db967e63be5b3a5f2a05e241f92cf0b40c
Author: Songtuan Lin <u6162630@anu.edu.au>
Date:   Tue May 1 21:49:28 2018 +1000

    Junit Test

commit d80e8857fe598109357455187abf5b23e74f0d9c
Merge: a5b5eff 2a00553
Author: Garrick <lst19941027@gmail.com>
Date:   Tue May 1 21:48:31 2018 +1000

    Merge remote-tracking branch 'origin/master'

commit a5b5eff7f00343503f4ffbf4c52b28eac8fd683d
Author: Songtuan Lin <u6162630@anu.edu.au>
Date:   Tue May 1 21:48:17 2018 +1000

    Junit Test & Task 8

commit 2a005530c4c50ab5e7af7f7d8e6042a810a9eb67
Author: xujiajia <u6528982@anu.edu.au>
Date:   Tue May 1 10:13:13 2018 +1000

    some comments and task10

commit 8d463483135b3c9d4ec3c495b966fec8c8868956
Merge: 0882b61 e2dfa4e
Author: xujiajia <u6528982@anu.edu.au>
Date:   Tue May 1 10:01:28 2018 +1000

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/comp1110/comp1110-ass2

commit e2dfa4e5fc035da3d27f1cd8b3cb202a907266b9
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Thu Apr 26 21:00:12 2018 +1000

    GetSupportersTest should not require supporters to be sorted

commit 484b89db8f5eadfdc2459aa89e53762cfdd7cbf6
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Thu Apr 26 16:25:26 2018 +1000

    simplify GetFlagsTest and improve error output

commit 0882b61a0008cd7ab4b52405cedc7e4d1af84484
Author: xujiajia <u6528982@anu.edu.au>
Date:   Wed Apr 18 17:46:24 2018 +1000

    stage D

commit f273a896303a4a5c901bd5fd38da05a950213e45
Merge: 0313627 64192ff
Author: xujiajia <u6528982@anu.edu.au>
Date:   Wed Apr 18 17:45:08 2018 +1000

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/u6275198/comp1110-ass2-wed18c

commit 64192ff0fd825d860d9d990f6c172ca7d9be962d
Merge: 7e1cce4 a49e64e
Author: Garrick <lst19941027@gmail.com>
Date:   Wed Apr 18 17:43:56 2018 +1000

    Merge remote-tracking branch 'origin/master'

commit 7e1cce418eeda4dca3ca70d454f7ae278ba908a9
Author: Songtuan Lin <u6162630@anu,edu.au>
Date:   Wed Apr 18 17:43:34 2018 +1000

    Stage D

commit a49e64ed82527d85b72e14157ef17ab5094cae8f
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Wed Apr 18 17:42:28 2018 +1000

    updated the originality document

commit 03136275f147cdc6e5bbcfed16261ef2aea7c186
Merge: 287b2b4 d0bcba6
Author: xujiajia <u6528982@anu.edu.au>
Date:   Wed Apr 18 17:37:44 2018 +1000

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/u6275198/comp1110-ass2-wed18c

commit 287b2b45425d2122fb6792e6353c02c6f1e58a6c
Author: xujiajia <u6528982@anu.edu.au>
Date:   Wed Apr 18 17:08:13 2018 +1000

    stage D

commit d0bcba627c76c62ff7d52f4cdd2b7e7e77952617
Merge: db49125 2dbf04b
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Wed Apr 18 16:45:53 2018 +1000

    Merge remote-tracking branch 'origin/master'

commit db491256a16708389f8ffc2404cdf2fa4fe45c6c
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Wed Apr 18 16:45:34 2018 +1000

    updated the originality document and working on task 10.

commit 3927735a845bfe2842b5cfbaa55a8c286aaf0d93
Merge: 2dbf04b 36c3e70
Author: xujiajia <u6528982@anu.edu.au>
Date:   Tue Apr 17 15:57:12 2018 +1000

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/comp1110/comp1110-ass2

commit 9c4f0a43fc893abb85bb1319e1cb1818d8e2ac62
Merge: a48fa87 36c3e70
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Tue Apr 17 15:24:06 2018 +1000

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/comp1110/comp1110-ass2

commit 36c3e706fb68df0e7de005e13e91be541cd8b3af
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Tue Apr 10 22:48:08 2018 +1000

    added tests: Task 8 GetFlagsTest and Task 10 GenerateMoveTest
    
    also renamed CardPlacementWellFormedTest to be consistent with others

commit 2dbf04b7b4c6ca4f7afcbba57a667b72d1db94e3
Author: xujiajia <u6528982@anu.edu.au>
Date:   Wed Mar 28 17:20:24 2018 +1100

    all finished

commit a48fa877bbfba7b065917b90fe7413828655a3f8
Author: Rufus <u6275198@anu.edu.au>
Date:   Wed Mar 28 12:35:21 2018 +1100

    updated the originality document

commit 260decc940ee693007d5471ed873394a333efa63
Author: Rufus <u6275198@anu.edu.au>
Date:   Wed Mar 28 12:29:40 2018 +1100

    added the images, and updated the Viewer #task 4 - Added a background border to the pane

commit 5cc6a1b447f9045c144f9da932528bcab0f4955b
Author: Rufus <u6275198@anu.edu.au>
Date:   Wed Mar 28 10:42:00 2018 +1100

    added the images, and updated the Viewer #task 4

commit 4b938f1f010eeeb4f228789941481416a958c5fc
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Wed Mar 28 10:38:52 2018 +1100

    added the images, and updated the Viewer #task 4

commit 7c8115ab107273b27629354e5b8425ed02aa6988
Merge: 7113592 fa0411a
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Wed Mar 28 01:08:55 2018 +1100

    Merge remote-tracking branch 'origin/master'

commit 711359228a90c454b5e09460a1c6ddfce0655f05
Author: Rufus Raja <u6275198@anu.edu.au>
Date:   Wed Mar 28 01:08:37 2018 +1100

    added the images, and updated the Viewer #task 4

commit fa0411abcf3194a8239864c5ea63af30b845d2ea
Merge: 21897e3 a2b96c7
Author: Garrick <lst19941027@gmail.com>
Date:   Tue Mar 27 23:57:11 2018 +1100

    Merge remote-tracking branch 'origin/master'
    
    # Conflicts:
    #       src/comp1110/ass2/Kingdom.java
    #       src/comp1110/ass2/Player.java
    #       src/comp1110/ass2/WarringStatesGame.java

commit 21897e34faaa2e06609ce25c3f1bfe96b5e029fb
Author: Songtuan Lin <u6162630@anu,edu.au>
Date:   Tue Mar 27 23:51:11 2018 +1100

    Task 5 to 7

commit a2b96c7ffbb192ec0754a155cf0a3fdbbb8f2a7d
Author: xujiajia <u6528982@anu.edu.au>
Date:   Tue Mar 27 01:39:21 2018 +1100

    task 02,03 finished

commit 614a8c976c4b4100ed4edf7ea8c860d0dbbfa96a
Merge: 39c764e 4d9a26d
Author: u6528982 <u6528982@anu.edu.au>
Date:   Wed Mar 21 18:57:09 2018 +1100

    Merge remote-tracking branch 'origin/master'
    
    # Conflicts:
    #       src/gittest/Main.java

commit 4d9a26def316ad3400750ec82bc85b8279f9f4f0
Merge: 253517b 281d1f3
Author: u6275198 <u6275198@anu.edu.au>
Date:   Wed Mar 21 18:55:59 2018 +1100

    Merge remote-tracking branch 'origin/master'
    
    # Conflicts:
    #       src/gittest/Main.java

commit 39c764e17f21d7b0d5b5f44aee31462744e460b2
Author: Cindy <u6528982@anu.edu.au>
Date:   Wed Mar 21 18:50:18 2018 +1100

    Cindy

commit 281d1f397d36faf000117a04ded748816838f5d0
Author: Bob <u6162630@anu.edu.au>
Date:   Wed Mar 21 18:49:06 2018 +1100

    Bob 3

commit 253517bb72ca14edf6c865377fbf36c98914eb37
Author: Alice <u6275198>
Date:   Wed Mar 21 18:49:05 2018 +1100

    Created object for A

commit 7c67ab490a5c39b2a6c45dbaa2df6c176013cdbb
Merge: b6c9119 c9649ad
Author: u6162630 <lst19941027@gmail.com>
Date:   Wed Mar 21 18:40:05 2018 +1100

    Merge remote-tracking branch 'origin/master'

commit c9649adf4c564ce314892ccd55bf652e4f20ceda
Author: Cindy <u6528982@anu.edu.au>
Date:   Wed Mar 21 18:38:47 2018 +1100

    Cindy

commit b6c911930f68fbdef230e5bf80eba6beb1b17247
Author: Bob <u1234567@anu.edu.au>
Date:   Wed Mar 21 18:32:04 2018 +1100

    Bob

commit 0fc3d4cf31e8b1058cc4c6356d587acd4d6f7a44
Author: u6275198 <u6275198@anu.edu.au>
Date:   Wed Mar 21 18:20:20 2018 +1100

    Added class A and Main

commit a5d73f74b63bd025df5cfa3163558da22a481480
Author: u6162630 <lst19941027@gmail.com>
Date:   Wed Mar 21 17:58:34 2018 +1100

    I did class Player and Kingdom and the method for task 7

commit bc2670f921ffa467ba1d748520b05b562ea2d1f0
Author: Songtuan Lin <u6162630>
Date:   Wed Mar 21 17:57:00 2018 +1100

    I did class Player and Kingdom and the method for task 7

commit d3470e05ac14ec873c8094674f82ac4f9d2f271b
Author: Rufus <u6275198@anu.edu.au>
Date:   Wed Mar 21 17:47:49 2018 +1100

    updated the originality.

commit fb5f476e8fcf4b04aec3a9ea861bbe3da42d5df9
Author: xujiajia <u6528982@anu.edu.au>
Date:   Wed Mar 21 17:44:19 2018 +1100

    methods for task 6 updated

commit 01df925c4b9ee6932c0d5e1de093dd24270f9b78
Author: Rufus <u6275198@anu.edu.au>
Date:   Wed Mar 21 17:39:05 2018 +1100

    Class Piece added, and methods isfarthest, getKingdom and isSameKingdom added.

commit de076fa2915387d7e742b17a1cf8679a334798f7
Author: xujiajia <u6528982@anu.edu.au>
Date:   Wed Mar 21 17:21:06 2018 +1100

    methods winner, setup, nextstep for class Game added

commit e8ce0dbf97ebf54ee75280482135f51eda765161
Merge: f97a509 ca2d2f4
Author: xujiajia <u6528982@anu.edu.au>
Date:   Wed Mar 21 10:17:24 2018 +1100

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/comp1110/comp1110-ass2

commit ca2d2f4d325faef911ef2bdfd6ca1e1c028e4697
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Mon Mar 19 18:58:31 2018 +1100

    fix to error message for CardPlacementWellFormed.testCase for valid string
    
    thanks to Jay Heyman for finding

commit f97a509bf95863b3e1a738adc8510a08692e68c8
Merge: 3ec3ed2 10a0d46
Author: xujiajia <u6528982@anu.edu.au>
Date:   Mon Mar 19 08:51:02 2018 +1100

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/comp1110/comp1110-ass2

commit 10a0d461c8d7f95f4cefc75d8feff0f4ee43115a
Merge: 9700ecf efff375
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Sun Mar 18 21:15:32 2018 +1100

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/comp1110/comp1110-ass2

commit 9700ecfaa66ba883caaaf32fc72a3af405931f13
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Sun Mar 18 21:13:59 2018 +1100

    fix to Task 5 testNoCard - included incorrect 'stay put' move for Zhang Yi
    
    thanks to Cooper Yang for finding this bug

commit efff3750e8fb92cf4f822b270d1d1915a71c2d29
Author: COMP1110 2018 S1 <josh.milthorpe+comp1110-2018s1@anu.edu.au>
Date:   Thu Mar 15 17:14:22 2018 +1100

    remove link to non-existent statement of originality

commit 55545e7867b9903ddbe9247c9a143ccc53655f63
Author: milthorpe <josh.milthorpe@gmail.com>
Date:   Wed Mar 14 23:46:03 2018 +1100

    fix typo in locations image

commit 3ec3ed2170dcae0017ea56bf5def4bfa4d0de686
Author: u6275198 <u6275198@anu.edu.au>
Date:   Wed Mar 14 18:57:51 2018 +1100

    members and roles assigned.

commit 1b174ce555d2c163322d3d0f0adc0efa961e1e5b
Author: u6275198 <u6275198@anu.edu.au>
Date:   Wed Mar 14 18:56:44 2018 +1100

    members and roles assigned.

commit b59a979d9604995508e01a7879daa031be2be6c7
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Tue Mar 13 17:25:19 2018 +1100

    fix CardPlacementWellFormed: was calling wrong method isPlacementWellFormed

commit adcde368e6588adec46a48f85782ab70c9644add
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Tue Mar 13 13:01:51 2018 +1100

    print out valid placement string in CardPlacementWellFormed.checkSimpleValid

commit a5266a419c512e3c432b240fee12f9fe69a1f246
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Tue Mar 13 12:43:58 2018 +1100

    isCardPlacementWellFormed specification should mention Zhang Yi (z9) is allowed

commit e2f00bd5b201e6065f70aa85d7b00a378129aae9
Author: milthorpe <josh.milthorpe@gmail.com>
Date:   Tue Mar 13 07:31:52 2018 +1100

    COMP1110 Assignment 2 2018 S1

commit cee45f5d06e0cd03de74b15abe6488a44bf89ee8
Author: milthorpe <josh.milthorpe@gmail.com>
Date:   Thu Mar 1 08:06:29 2018 +1100

    Initial commit
```
## Changes
```
Only in comp1110-ass2/admin: A-Members.md
diff -ru -x .git ../master/comp1110-ass2/admin/B-contribution.md comp1110-ass2/admin/B-contribution.md
--- ../master/comp1110-ass2/admin/B-contribution.md	2018-05-18 08:54:16.257374551 +1000
+++ comp1110-ass2/admin/B-contribution.md	2018-05-18 10:03:51.935223142 +1000
@@ -1,7 +1,7 @@
 We declare that the work toward our submission of Stage B was distributed among the group members as follows:
 
-* u2345678 30
-* u3456789 40
-* u0234567 30
+* u6528982 30
+* u6162630 35
+* u6275198 35
 
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0234567)
+Signed: Jiajia Xu (u6528982), Songtuan Lin (u6162630), and John Rufus Raja(u6275198)
diff -ru -x .git ../master/comp1110-ass2/admin/B-originality.md comp1110-ass2/admin/B-originality.md
--- ../master/comp1110-ass2/admin/B-originality.md	2018-05-18 08:54:16.273374638 +1000
+++ comp1110-ass2/admin/B-originality.md	2018-05-18 10:03:51.951223227 +1000
@@ -1,9 +1,5 @@
 We declare that the work we have submitted for Stage B of this assignment and all stages before it is entirely our own work, with the following documented exceptions:
 
-* The idea of using <...> to make the game run faster came from a discussion with <...> (noted in source code comments)
+No exceptions, results based on discussions and efforts within the team.
 
-* The code in class <...> is based on a solution we found when researching the problem (URL provided in source code comments)
-
-*  ....
-
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0123456)
+Signed: Jiajia Xu (u6528982), Songtuan Lin (u6162630), and John Rufus Raja(u6275198)
diff -ru -x .git ../master/comp1110-ass2/admin/C-contribution.md comp1110-ass2/admin/C-contribution.md
--- ../master/comp1110-ass2/admin/C-contribution.md	2018-05-18 08:54:16.285374702 +1000
+++ comp1110-ass2/admin/C-contribution.md	2018-05-18 10:03:51.963223291 +1000
@@ -1,7 +1,8 @@
 We declare that the work toward our submission of Stage C was distributed among the group members as follows:
 
-* u2345678 30
-* u3456789 40
-* u0234567 30
 
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0234567)
+* u6528982 30
+* u6162630 40
+* u6275198 30
+
+Signed: Jiajia Xu (u6528982), Songtuan Lin (u6162630), and John Rufus Raja(u6275198)
diff -ru -x .git ../master/comp1110-ass2/admin/C-originality.md comp1110-ass2/admin/C-originality.md
--- ../master/comp1110-ass2/admin/C-originality.md	2018-05-18 08:54:16.293374746 +1000
+++ comp1110-ass2/admin/C-originality.md	2018-05-18 10:03:51.975223354 +1000
@@ -1,9 +1,5 @@
 We declare that the work we have submitted for Stage C of this assignment and all stages before it is entirely our own work, with the following documented exceptions:
 
-* The idea of using <...> to make the game run faster came from a discussion with <...> (noted in source code comments)
+1. The objective for task 4 was discussed, however, the implementation was done without support. The concept of GridPanes was taken from stackoverflow.
 
-* The code in class <...> is based on a solution we found when researching the problem (URL provided in source code comments)
-
-*  ....
-
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0123456)
+Signed: Jiajia Xu (u6528982), Songtuan Lin (u6162630), and John Rufus Raja(u6275198)
Only in ../master/comp1110-ass2/admin: D-originality-u1234567.md
Only in comp1110-ass2/admin: D-originality-u6162630.md
Only in comp1110-ass2/admin: D-originality-u6275198.md
Only in comp1110-ass2/admin: D-originality-u6528982.md
Only in ../master/comp1110-ass2/admin: E-originality-u1234567.md
Only in comp1110-ass2/admin: E-originality-u6162630.md
Only in comp1110-ass2/admin: E-originality-u6275198.md
Only in comp1110-ass2/admin: E-originality-u6528982.md
diff -ru -x .git ../master/comp1110-ass2/admin/F-contribution.md comp1110-ass2/admin/F-contribution.md
--- ../master/comp1110-ass2/admin/F-contribution.md	2018-05-18 08:54:16.337374984 +1000
+++ comp1110-ass2/admin/F-contribution.md	2018-05-18 10:03:52.055223780 +1000
@@ -1,8 +1,9 @@
-We declare that the work toward our submission of Stage F was distributed among the group members as follows:
+We declare that the work toward our submission of Stage C was distributed among the group members as follows:
 
-* u2345678 30
-* u3456789 40
-* u0123456 30
 
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0123456)
+* u6528982 32
+* u6162630 34
+* u6275198 34
+
+Signed: Jiajia Xu (u6528982), Songtuan Lin (u6162630), and John Rufus Raja(u6275198)
 
diff -ru -x .git ../master/comp1110-ass2/admin/F-originality.md comp1110-ass2/admin/F-originality.md
--- ../master/comp1110-ass2/admin/F-originality.md	2018-05-18 08:54:16.357375092 +1000
+++ comp1110-ass2/admin/F-originality.md	2018-05-18 10:03:52.067223844 +1000
@@ -1,9 +1,5 @@
 We declare that the work we have submitted for Stage F of this assignment and all stages before it is entirely our own work, with the following documented exceptions:
 
-* The idea of using <...> to make the game run faster came from a discussion with <...> (noted in source code comments)
+no exceptions.
 
-* The code in class <...> is based on a solution we found when researching the problem (URL provided in source code comments)
-
-* ....
-
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0123456)
+Signed: Jiajia Xu (u6528982), Songtuan Lin (u6162630), and John Rufus Raja(u6275198)
Only in ../master/comp1110-ass2/admin: F-review-u1234567.md
Only in comp1110-ass2/admin: F-review-u6162630.md
Only in comp1110-ass2/admin: F-review-u6275198.md
Only in comp1110-ass2/admin: F-review-u6528982.md
Only in ../master/comp1110-ass2/admin: G-best-u1234567.md
Only in comp1110-ass2/admin: G-best-u6162630.md
Only in comp1110-ass2/admin: G-best-u6275198.md
Only in comp1110-ass2/admin: G-best-u6528982.md
diff -ru -x .git ../master/comp1110-ass2/admin/G-contribution.md comp1110-ass2/admin/G-contribution.md
--- ../master/comp1110-ass2/admin/G-contribution.md	2018-05-18 08:54:16.389375265 +1000
+++ comp1110-ass2/admin/G-contribution.md	2018-05-18 10:03:52.147224269 +1000
@@ -1,8 +1,7 @@
 We declare that the work toward our submission of Stage G was distributed among the group members as follows:
 
-* u2345678 30
-* u3456789 40
-* u0123456 30
-
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0123456)
+* u6275198 35
+* u6528982 30
+* u6162630 35
 
+Signed: Jiajia Xu (u6528982), Songtuan Lin (u6162630), and John Rufus Raja(u6275198)
diff -ru -x .git ../master/comp1110-ass2/admin/G-features.md comp1110-ass2/admin/G-features.md
--- ../master/comp1110-ass2/admin/G-features.md	2018-05-18 08:54:16.397375309 +1000
+++ comp1110-ass2/admin/G-features.md	2018-05-18 10:03:52.163224354 +1000
@@ -13,4 +13,10 @@
 
 additional features...
 
+ - A unique GUI based on the theme of Marvel and DC comics.
+ - Audio tracks in-line with the them that can be toggled, with prompts from Loki, every few moves into the game.
+ - An instruction page, guiding any new players on how to play the game. 
+ - Multi-player option up to 4 players, playing simultaneously. 
+
+
 
diff -ru -x .git ../master/comp1110-ass2/admin/G-originality.md comp1110-ass2/admin/G-originality.md
--- ../master/comp1110-ass2/admin/G-originality.md	2018-05-18 08:54:16.409375374 +1000
+++ comp1110-ass2/admin/G-originality.md	2018-05-18 10:03:52.179224439 +1000
@@ -1,9 +1,6 @@
 We declare that the work we have submitted for Stage G of this assignment and all stages before it is entirely our own work, with the following documented exceptions:
 
-* The idea of using <...> to make the game run faster came from a discussion with <...> (noted in source code comments)
+* Some code was referenced from stackoverflow, but the idea behind the implementation itself, was original.
+* Images have been picked up and modified from free images available on google.
 
-* The code in class <...> is based on a solution we found when researching the problem (URL provided in source code comments)
-
-* ....
-
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0123456)
+Signed: John Rufus Raja (u6275198), Jiajia Xu (u6528982), and Songtuan Lin (u6162630)
Only in comp1110-ass2: feedback.md
Only in comp1110-ass2: game.jar
Only in comp1110-ass2/.idea: artifacts
diff -ru -x .git ../master/comp1110-ass2/.idea/misc.xml comp1110-ass2/.idea/misc.xml
--- ../master/comp1110-ass2/.idea/misc.xml	2018-05-18 08:54:16.109373750 +1000
+++ comp1110-ass2/.idea/misc.xml	2018-05-18 10:03:51.803222440 +1000
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="false" project-jdk-name="1.8" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/out" />
   </component>
 </project>
\ No newline at end of file
Only in comp1110-ass2: META-INF
Only in comp1110-ass2: presentation.pdf
Only in comp1110-ass2/src/comp1110/ass2: Card.class
Only in comp1110-ass2/src/comp1110/ass2: Card.java
diff -ru -x .git ../master/comp1110-ass2/src/comp1110/ass2/gui/assets/characters.md comp1110-ass2/src/comp1110/ass2/gui/assets/characters.md
--- ../master/comp1110-ass2/src/comp1110/ass2/gui/assets/characters.md	2018-05-18 08:54:17.101379117 +1000
+++ comp1110-ass2/src/comp1110/ass2/gui/assets/characters.md	2018-05-18 10:03:57.415252284 +1000
@@ -35,7 +35,7 @@
 - Lian Po 廉頗
 
 ## Han 韓
-- Marquess Ai 韩哀侯
+- Marquess Ai 韩哀侯趙姬
 - King Huanhui 桓惠王
 - King An 安王
 - Han Fei 韓非
Only in comp1110-ass2/src/comp1110/ass2/gui: Game$1.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Game$2.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Game$3.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Game$4.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Game$5.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Game$6$1.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Game$6.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Game$7.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Game.class
diff -ru -x .git ../master/comp1110-ass2/src/comp1110/ass2/gui/Game.java comp1110-ass2/src/comp1110/ass2/gui/Game.java
--- ../master/comp1110-ass2/src/comp1110/ass2/gui/Game.java	2018-05-18 08:54:16.585376326 +1000
+++ comp1110-ass2/src/comp1110/ass2/gui/Game.java	2018-05-18 10:03:56.899249540 +1000
@@ -1,21 +1,1143 @@
 package comp1110.ass2.gui;
 
+
+import com.sun.org.apache.bcel.internal.generic.IF_ACMPEQ;
+import comp1110.ass2.Card;
+import java.util.*;
 import javafx.application.Application;
+import javafx.application.Platform;
+import javafx.collections.FXCollections;
+import javafx.event.ActionEvent;
+import javafx.event.EventHandler;
+import javafx.geometry.Insets;
+import javafx.scene.Group;
+import javafx.scene.Scene;
+import javafx.scene.control.*;
+import javafx.scene.image.Image;
+import javafx.scene.image.ImageView;
+import javafx.scene.input.KeyCode;
+import javafx.scene.input.KeyEvent;
+import javafx.scene.layout.*;
+import javafx.scene.media.AudioClip;
+import javafx.scene.paint.Color;
+import javafx.scene.shape.Rectangle;
+import javafx.scene.text.Font;
+import javafx.scene.text.FontWeight;
+import javafx.scene.text.Text;
+import javafx.stage.Modality;
 import javafx.stage.Stage;
 
+import java.util.Random;
+import comp1110.ass2.WarringStatesGame;
+
+
+
+import static comp1110.ass2.WarringStatesGame.*;
+import static javafx.application.Platform.exit;
+
 public class Game extends Application {
-    private static final int BOARD_WIDTH = 933;
-    private static final int BOARD_HEIGHT = 700;
+    static int num_players = 0;
+
+    Card p = new Card();
+    String getMove;
+    String getBotMove;
+    GridPane gridPane = new GridPane();
+    private static final int VIEWER_WIDTH = 933;
+    private static final int VIEWER_HEIGHT = 700;
+    String boardMatrix[][];
+    static String playerName[];
+    VBox flags;
+    public Button button = new Button("Play");
+    private static final String URI_BASE = "assets/";
+    String placement1,setup;
+    private static final Pane root = new Pane();
+    private final Pane introroot = new Pane();
+    private final Group controls = new Group();
+    static int flag[] = new int[7];
+    static int botFlag[][] = new int[7][7];
+    public static int cardCount[] = new int[7];
+    static String roundGains[] = new String[7];
+    TextField textField,player1,player2,player3,player4;
+    Label qinF  = new Label(" ");
+    Label qiF    = new Label(" ");
+    Label chuF   = new Label(" ");
+    Label zhaoF  = new Label(" ");
+    Label hanF   = new Label(" ");
+    Label weiF   = new Label(" ");
+    Label yanF   = new Label(" ");
+    int mCount = 0;
+    int titanCount = 0;
+    static Label winnerID = new Label(" ");;
+    String moveSequence = "";
+    String botMoveSequence = "";
+    static int winner=0;
+    public int player =-1;
+    boolean check = true;
+    boolean botPlay = true;
+    boolean titan = false;
+    Thread t;
+    GridPane pane = new GridPane();
+    static Text declareWinner = new Text(45,350,"");
+
+    /*Declaring all the audio clips to be used*/
+    AudioClip click1 = new AudioClip("http://www.wavlist.com/soundfx/020/clock-tick1.wav");
+    AudioClip scene1player = new AudioClip(this.getClass().getResource("/resource/Immigrant.mp3").toString());
+    AudioClip scene2player = new AudioClip(this.getClass().getResource("/resource/z_avengers.mp3").toString());
+    AudioClip lokiIntro = new AudioClip(this.getClass().getResource("/resource/LokiIntro.wav").toString());
+    AudioClip lokiIntro1 = new AudioClip(this.getClass().getResource("/resource/LokiIntroTalk.wav").toString());
+    AudioClip loki1 = new AudioClip(this.getClass().getResource("/resource/Loki1.wav").toString());
+    AudioClip loki2 = new AudioClip(this.getClass().getResource("/resource/Loki2.wav").toString());
+    AudioClip loki3 = new AudioClip(this.getClass().getResource("/resource/Loki3.wav").toString());
+    AudioClip loki4 = new AudioClip(this.getClass().getResource("/resource/Loki4.wav").toString());
+    AudioClip loki5 = new AudioClip(this.getClass().getResource("/resource/Loki5.wav").toString());
+    AudioClip lokiEnding = new AudioClip(this.getClass().getResource("/resource/LokiEnding.wav").toString());
+    AudioClip click2 = new AudioClip(this.getClass().getResource("/resource/clicksound.mp3").toString());
+
+    Label sp1 = new Label();
+    Label sp2 = new Label();
+    Label sp3 = new Label();
+    Label sp4 = new Label();
+    HBox scoreLabels = new HBox();
+    Text scores1 = new Text();
+    Text scores2 = new Text();
+    Text scores3 = new Text();
+    Text scores4 = new Text();
+    Text cards1 = new Text();
+    Text cards2 = new Text();
+    Text cards3 = new Text();
+    Text cards4 = new Text();
+    HBox scores = new HBox();
+
+    /*Randomize the starting placement string*/
+    static final String[] PLACEMENTS = {
+            "g0Aa0Bf1Ca1Dc5Ee1Fa4Ge3He2Ia2Jc2Kd0Lf0Mb4Nd4Oa6Pc3Qe0Ra5Sc1Td1Uc4Vb5Wb0Xa7Yf2Zb10a31z92b33b64d35g16b27d28c09",
+            "g1Aa0Bc0Ce0De3Ed4Fb6Ga4Hg0Ib5Ja7Kb1Lz9Me1Nd0Of0Pf1Qb2Rc1Sd3Ta5Ub4Va2Wc5Xd1Ya3Zc20d21c32f23a64c45b36b07a18e29",
+            "b5Ae0Bc3Ca7Da1Ec1Fg1Gg0Ha0If0Jb2Kb1La3Ma2Nb0Oc5Pe2Qd0Rd2Sd4Td3Ua4Va5Wb6Xb3Yb4Zz90f11a62e33c04f25c46c27d18e19",
+            "c3Aa6Ba1Ca5Dd0Ee3Fa3Gc0Hb1Ic5Jz9Kb3Lb5Mf1Nf0Ob4Pc4Qa0Rd2Sa7Te0Ug1Ve1Wg0Xb6Yb0Zd40d11f22c13b24c25a26d37a48e29",
+            "e2Ab4Bc0Cb1Dd4Ed0Fz9Gg0Ha4Ia7Jf2Kc2Lc5Mb2Nf0Oe3Pb6Qa6Re0Sf1Tc1Uc4Vg1Wa3Xa0Yb0Zc30e11a22b33b54a15d26a57d18d39",
+            "g1Ab2Ba4Ce2Dd4Eb4Fc3Gf1Ha2Ig0Jc2Kd2Le1Ma1Nb6Oc0Pc1Qe0Rf0Sf2Tb3Uc4Vc5Wb5Xd1Ya7Za00z91d02b03a54a65d36b17e38a39",
+            "b4Aa2Bz9Cf1Dd0Ea7Ff0Gb0Hb5Id4Jd2Kf2Lc3Mc4Nd1Oa0Pa1Qa4Re2Se1Tc5Uc0Vg0Wb6Xb1Ya3Za60d31c22a53b24e35g16e07b38c19",
+            "c5Aa6Bf0Cb0Da2Ea5Fc0Gb2Ha3Ib6Jd4Kb3Lb1Mc1Nc4Od3Pg0Qd1Re3Se2Ta0Ud2Ve1Wz9Xd0Ye0Zf20a11c22a73f14b55c36g17b48a49",
+            "c2Az9Bb4Cb2Dc1Ea6Fa7Ga4Hg0Ia1Jd1Ke0Lf0Mb1Nc0Of1Pd0Qg1Rd3Sc4Te2Ub5Vf2We1Xb0Ya5Zb30d21a32b63a04d45c36c57e38a29",
+            "a4Aa2Bb2Cc0Dc5Eb4Fa5Gc4Hf1Ia0Jf0Ke1Lb5Mc2Na3Of2Pz9Qb1Rd0Sd2Td3Ub6Vc1We2Xe3Yb0Zb30g01a12a73c34a65d46d17e08g19",
+            "b5Ae0Bb0Ca2De2Ec3Fa7Gf0Hd2Ia1Jc1Kd1La4Mb6Nd3Oa5Pc5Qe1Ra0Sf1Tg1Ub1Vb4Wa3Xc4Yb2Za60d41c22g03f24e35c06d07b38z99",
+            "e2Ad4Bb6Cf1Da3Ed0Fa5Ga0Hg0Ia7Je0Kc4Lg1Md2Ne1Oc1Pf0Qc3Rd1Sb3Tc2Uc0Va2Wb2Xa1Ya4Zd30b11c52f23b54b45e36a67b08z99",
+            "d4Ad1Ba7Cb3Db1Ee1Fd3Gc3Hb6Ic2Ja2Kf0Lc5Me3Ng0Oz9Pd2Qg1Rc0Sa5Tb4Ud0Va1Wf2Xe2Ya6Za40b01b22b53e04a05a36c17f18c49",
+            "b3Ab0Bd2Ce2Da7Ea4Ff0Gd4He1Ia0Jg0Kb6Lc5Mz9Nc0Oe3Pe0Qa3Rb4Sa2Tf2Ug1Vc1Wc4Xa1Yc2Za50f11c32b23d14d05d36b57a68b19",
+            "f1Aa7Ba0Cb6Da5Ec3Fb0Gc2Hg0Ie3Ja6Kc4La4Mf2Ne1Of0Pd2Qb3Rd3Sb2Tb1Ue0Ve2Wc0Xd1Yc5Zb40d01b52a33d44a15c16z97a28g19",
+            "e1Af2Bc4Ce0Dg1Ea7Fa0Gg0Hc3Ib4Jd3Kc1Lb5Mc0Ne2Od1Pd2Qa2Rb3Sc5Td4Ub1Vf0Wb0Xa1Ya3Ze30a41z92c23a64b25a56b67f18d09",
+            "b0Ac0Bf1Cb4De1Ea3Fc2Gz9Hb3Ia5Jc5Ke2Lb1Mf2Nd2Og0Pf0Qc4Rb2Sg1Ta7Ub5Vd4Wc3Xd1Ye0Ze30c11a62a03d34a25b66a17a48d09",
+            "a7Aa0Bb5Cg1Dd0Ea6Fe3Ga4Hg0Ie2Je1Ka3Lb3Md1Nd2Oz9Pb4Qd4Rc3Sf1Tc4Ua5Vb2Wb1Xc1Yf0Zb60d31c52b03f24c25a26a17c08e09",
+            "e3Ad4Ba5Cd1Dc1Eb3Fc5Gd2Hg0Ie0Ja2Kb5Lf1Md3Na6Oz9Pb1Qc3Rf2Sc4Tb0Uc0Ve1Wd0Xg1Ye2Zb60a71a32a03b24a45b46f07c28a19",
+            "g0Ac1Bb4Ca5Da2Ea6Ff0Gb1Ha3Id3Ja0Kz9Lc5Mb0Nf1Od2Pe1Qc2Re3Sb6Td0Ub5Va1Wb2Xc3Yb3Zc00e21e02a73d14f25a46g17c48d49"
+    };
 
-    // FIXME Task 9: Implement a basic playable Warring States game in JavaFX
+    /*Array of image objects*/
+    Image[][] grid2 =
+            {
+                    {p.a0, p.a1, p.a2, p.a3, p.a4, p.a5, p.a6, p.a7},
+                    {p.b0, p.b1, p.b2, p.b3, p.b4, p.b5, p.b6},
+                    {p.c0, p.c1, p.c2, p.c3, p.c4, p.c5},
+                    {p.d0, p.d1, p.d2, p.d3, p.d4},
+                    {p.e0, p.e1, p.e2, p.e3},
+                    {p.f0, p.f1, p.f2},
+                    {p.g0, p.g1},
+                    {p.z9}
+            };
 
-    // FIXME Task 11: Allow players of your Warring States game to play against your simple agent
+    /*Declare all the positions on the baord in an array*/
+    static final char c[] = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'};
 
-    // FIXME Task 12: Integrate a more advanced opponent into your game
 
+    /**
+     * Method to modify the Board after every move
+     * @param placement
+     * Author: Rufus Raja (u6275198)
+     */
+    void makePlacement(String placement) {
+
+        button.setDisable(false);
+        textField.setDisable(false);
+        textField.requestFocus();
+        String sub[] = new String[placement.length() / 3];
+        int rown = 0, coln = 0,col=5;
+        Random r = new Random();
+        int selector = r.nextInt(20);
+        Image[][] grid = new Image[6][6];
+        sub = substr(placement,3);
+        /*Get the grid for the image changes in the placement string*/
+        for (int y = 0; y < sub.length; y++) {
+            if (sub[y].charAt(0) == 'z') {
+                rown = 7;
+                coln = 0;
+            } else {
+                rown = sub[y].charAt(0) - 'a';
+                coln = sub[y].charAt(1) - '0';
+            }
+            if (sub[y].charAt(2) >= 65 && sub[y].charAt(2) <= 70) {
+                int row = sub[y].charAt(2) % 13;
+                grid[row][col] = grid2[rown][coln];
+            }
+            if (sub[y].charAt(2) >= 71 && sub[y].charAt(2) <= 76) {
+                int row = (sub[y].charAt(2) % 71) ;
+                grid[row][col-1] = grid2[rown][coln];
+            }
+            if (sub[y].charAt(2) >= 77 && sub[y].charAt(2) <= 82) {
+                int row = (sub[y].charAt(2) % 77) ;
+                grid[row][col-2] = grid2[rown][coln];
+            }
+            if (sub[y].charAt(2) >= 83 && sub[y].charAt(2) <= 88) {
+                int row = (sub[y].charAt(2) % 83) ;
+                grid[row][col-3] = grid2[rown][coln];
+            }
+            if (sub[y].charAt(2) >= 89 && sub[y].charAt(2) <= 90) {
+                int row = (sub[y].charAt(2) % 89);
+                grid[row][col-4] = grid2[rown][coln];
+            }
+            if (sub[y].charAt(2) >= 48 && sub[y].charAt(2) <= 51) {
+                int row = (sub[y].charAt(2) % 23);
+                grid[row][col-4] = grid2[rown][coln];
+            }
+            if (sub[y].charAt(2) >= 52 && sub[y].charAt(2) <= 57) {
+                int row = (sub[y].charAt(2) % 52);
+                grid[row][col-5] = grid2[rown][coln];
+            }
+
+
+        }
+        /*Defining the grid properties*/
+        gridPane.setHgap(2);
+        gridPane.setVgap(2);
+        gridPane.autosize();
+        gridPane.setStyle("-fx-background-color: White; -fx-border-color: Black ");
+        gridPane.setPadding(new Insets(1,1,1,1));
+
+        for (int x = 0; x < grid.length; x++) {
+            for (int y = 0; y < grid[x].length; y++) {
+                ImageView imageView = new ImageView(grid[x][y]);
+                imageView.setFitWidth(100);
+                imageView.setFitHeight(100);
+                gridPane.add(imageView, y, x);
+            }
+        }
+        grid = null;
+    }
+
+    /**
+     * Substring function that can break the placement string to required number of characters, and returns a String array
+     * @param placement
+     * @param pos
+     * @return
+     * Author: Rufus Raja (u6275198)
+     */
+    private String[] substr(String placement,int pos)
+    {
+        int count =0;
+        String sub[] = new String[placement.length()/pos];
+        for (int x = 0; x < placement.length(); x += pos) {
+            sub[count] = placement.substring(x, x + pos);
+            count++;
+        }
+        return sub;
+    }
+
+    int numOfTimes = 0;
+
+    /**
+     * Create the elements for the game movements
+     * Author: Rufus Raja (u6275198)
+     */
+    private void makeControls() {
+        Label playerMoveLabel = new Label("Player Move:");
+        playerMoveLabel.setTextFill(Color.WHITE);
+        textField = new TextField();
+        textField.setPrefWidth(150);
+
+        Button newGame = new Button("New Game");
+        /*Check if the button was pressed*/
+        button.setOnAction(new EventHandler<ActionEvent>() {
+            @Override
+            public void handle(ActionEvent e) {
+                if(!textField.getText().equals("") || !textField.getText().equals(" "))
+                    singleMove();
+            }
+        });
+        /*Check if the Enter key was pressed*/
+        textField.setOnKeyPressed(new EventHandler<KeyEvent>()
+        {
+            @Override
+            public void handle(KeyEvent ke)
+            {
+                if (ke.getCode().equals(KeyCode.ENTER) && (!textField.getText().equals("") || !textField.getText().equals(" ")))
+                {
+                    singleMove();
+                }
+            }
+        });
+        HBox hb = new HBox();
+        hb.getChildren().addAll(playerMoveLabel, textField, button);
+        hb.setSpacing(10);
+        hb.setLayoutX(175);
+        hb.setLayoutY(VIEWER_HEIGHT-50);
+        controls.getChildren().add(hb);
+    }
+
+    private void singleMove() {
+        click1.setVolume(0.3);
+        click1.play();
+        mCount=mCount+1;
+        numOfTimes = 0;
+        /*Modulate the audio based on the moves*/
+        if(mCount%5 == 0 && numOfTimes == 0) {
+            loki1.play();
+            numOfTimes = 1;
+        }
+        if(mCount%7 == 0 && numOfTimes == 0){
+            loki2.play();
+            numOfTimes = 1;
+        }
+        if(mCount%9 == 0 && numOfTimes == 0){
+            loki3.play();
+            numOfTimes = 1;
+        }
+        if(mCount%11 == 0 && numOfTimes == 0){
+            loki4.play();
+            numOfTimes = 1;
+        }
+        if(mCount%13 == 0 && numOfTimes == 0){
+            loki5.play();
+            numOfTimes = 1;
+        }
+        getMove = textField.getText();
+        String validCheck  = textField.getText();
+        if (getMove.length() > 1)
+        {
+            textField.clear();
+        }
+        else
+        {
+            nextStep();
+        }
+        /*Executes the AI moves*/
+        if(playerName[1].equals("Omega(AI)") && check && botPlay)
+        {
+            button.setDisable(true);
+            textField.setDisable(true);
+            getMove = alpha_beta_search(placement1, boardMatrix) + "";//Call the advanced AI
+            delay(2000, new Runnable(){ public void run(){ nextStep();} });//Delay execution by 2 secs
+        }
+        textField.clear();
+
+    }
+
+    /**
+     * Simple agent moves
+     * @return
+     * Author: Rufus Raja (u6275198)
+     */
+    public char BotMove()
+    {
+        return generateMove(placement1);
+    }
+
+    /**
+     * Method to create delays in the processing
+     * @param delayMs
+     * @param toRun
+     * Author: Rufus Raja (u6275198)
+     */
+    public static void delay(long delayMs, Runnable toRun){
+        Thread t = new Thread(new Runnable(){
+            public void run(){
+                try { Thread.sleep(delayMs); }catch(InterruptedException ignored){}
+                Platform.runLater(toRun);
+            }
+        });
+        t.setDaemon(true);
+        t.start();
+    }
+
+    /**
+     * Declaring the main components for the board and the application design
+     * @param primaryStage
+     * @throws Exception
+     * Author: Rufus Raja (u6275198)
+     */
     @Override
     public void start(Stage primaryStage) throws Exception {
+        primaryStage.setTitle("The Comic Wars");
+        qinF.setTextFill(Color.WHITE.brighter());
+        qiF.setTextFill(Color.WHITE.brighter());
+        chuF.setTextFill(Color.WHITE.brighter());
+        zhaoF.setTextFill(Color.WHITE.brighter());
+        hanF.setTextFill(Color.WHITE.brighter());
+        weiF.setTextFill(Color.WHITE.brighter());
+        yanF.setTextFill(Color.WHITE.brighter());
+        scoreLabels.setLayoutX(760);
+        scoreLabels.setLayoutY(470);
+        VBox p1Score = new VBox();
+        VBox p2Score = new VBox();
+        VBox p3Score = new VBox();
+        VBox p4Score = new VBox();
+        p1Score.setLayoutX(693);
+        p1Score.setLayoutY(462);
+        p2Score.setLayoutX(753);
+        p2Score.setLayoutY(462);
+        p3Score.setLayoutX(813);
+        p3Score.setLayoutY(462);
+        p4Score.setLayoutX(873);
+        p4Score.setLayoutY(462);
+        Label scoreHead = new Label("SCORES");
+        scoreHead.setTextFill(Color.WHITE);
+        scoreHead.setFont(Font.font("Verdana", FontWeight.BOLD, 12));;
+        scoreHead.setLayoutX(854);
+        scoreHead.setLayoutY(444);
+        Label flagCount = new Label("Teams: ");
+        Label cardCount = new Label("Cards: ");
+        flagCount.setLayoutX(638);
+        flagCount.setLayoutY(484);
+        cardCount.setLayoutX(638);
+        cardCount.setLayoutY(507);
+        cardCount.setFont(Font.font("Arial Black", FontWeight.BOLD, 10));
+        flagCount.setFont(Font.font("Arial Black", FontWeight.BOLD, 10));
+        cardCount.setTextFill(Color.WHITE);
+        flagCount.setTextFill(Color.WHITE);
+        sp1.setTextFill(Color.WHITE.brighter());
+        sp2.setTextFill(Color.WHITE.brighter());
+        sp3.setTextFill(Color.WHITE.brighter());
+        sp4.setTextFill(Color.WHITE.brighter());
+        scores1.setFill(Color.WHITE.brighter());
+        scores2.setFill(Color.WHITE.brighter());
+        scores3.setFill(Color.WHITE.brighter());
+        scores4.setFill(Color.WHITE.brighter());
+        scores1.setFont(Font.font("Arial Black", FontWeight.BOLD, 14));
+        scores2.setFont(Font.font("Arial Black", FontWeight.BOLD, 14));
+        scores3.setFont(Font.font("Arial Black", FontWeight.BOLD, 14));
+        scores4.setFont(Font.font("Arial Black", FontWeight.BOLD, 14));
+        cards1.setFill(Color.WHITE.brighter());
+        cards2.setFill(Color.WHITE.brighter());
+        cards3.setFill(Color.WHITE.brighter());
+        cards4.setFill(Color.WHITE.brighter());
+        cards1.setFont(Font.font("Arial Black", FontWeight.BOLD, 14));
+        cards2.setFont(Font.font("Arial Black", FontWeight.BOLD, 14));
+        cards3.setFont(Font.font("Arial Black", FontWeight.BOLD, 14));
+        cards4.setFont(Font.font("Arial Black", FontWeight.BOLD, 14));
+        p1Score.getChildren().addAll(sp1,scores1,cards1);
+        p2Score.getChildren().addAll(sp2,scores2,cards2);
+        p3Score.getChildren().addAll(sp3,scores3,cards3);
+        p4Score.getChildren().addAll(sp4,scores4,cards4);
+        p1Score.setSpacing(3);
+        p2Score.setSpacing(3);
+        p3Score.setSpacing(3);
+        p4Score.setSpacing(3);
+        scoreLabels.setSpacing(20);
+        scores.setSpacing(60);
+        gridPane.setLayoutX(15);
+        gridPane.setLayoutY(10);
+        root.getChildren().add(gridPane);
+        Scene scene = new Scene(root, VIEWER_WIDTH, VIEWER_HEIGHT);
+        Scene intro = new Scene(introroot, VIEWER_WIDTH,VIEWER_HEIGHT);
+        /*Declaring the background images and modifying the background for the scenes*/
+        intro.getStylesheets().addAll(this.getClass().getResource("/resource/style.css").toExternalForm());
+        Image img = new Image("/resource/z9_background.jpg");
+        Image img2 = new Image("/resource/z10_background.jpg");
+        introroot.setBackground(new Background(new BackgroundImage(img,
+                BackgroundRepeat.NO_REPEAT, BackgroundRepeat.NO_REPEAT,
+                BackgroundPosition.CENTER,
+                new BackgroundSize(BackgroundSize.AUTO, BackgroundSize.AUTO, false, false, true, true))));
+        root.setBackground(new Background(new BackgroundImage(img2,
+                BackgroundRepeat.NO_REPEAT, BackgroundRepeat.NO_REPEAT,
+                BackgroundPosition.CENTER,
+                new BackgroundSize(BackgroundSize.AUTO, BackgroundSize.AUTO, false, false, true, true))));
+        ChoiceBox player = new ChoiceBox<>();
+        HBox selection = new HBox();
+        HBox playerIDs = new HBox();
+        VBox kingdoms = new VBox();
+        Label p1   = new Label("Player Names");
+        p1.setTextFill(Color.WHITE);
+        p1.setFont(Font.font("Arial Black", FontWeight.BOLD, 14));
+        kingdoms.setSpacing(30);
+        kingdoms.setLayoutX(750);
+        kingdoms.setLayoutY(70);
+        playerIDs.setSpacing(20);
+        playerIDs.setLayoutX(740);
+        playerIDs.setLayoutY(10);
+        Button startGame = new Button("Start Game");
+        Button help = new Button("Instructions");
+        Button mutemusic = new Button("Music On/Off");
+        HBox sounds = new HBox();
+        sounds.getChildren().addAll(mutemusic);
+        sounds.setSpacing(40);
+        sounds.setLayoutX(15);
+        sounds.setLayoutY(650);
+        startGame.setLayoutX(400);
+        startGame.setLayoutY(550);
+        help.setLayoutX(500);
+        help.setLayoutY(550);
+        player.setItems(FXCollections.observableArrayList(
+                "1 Player","2 Players","3 Players","4 Players"));
+        player.setValue("1 Player");
+        selection.setLayoutX(VIEWER_HEIGHT/2);
+        selection.setLayoutY(VIEWER_WIDTH/2);
+        player.setLayoutY(250);
+        player.setLayoutX(445);
+        VBox playerLabels = new VBox();
+        Label player1name = new Label("Player 1");
+        Label player2name = new Label("Player 2");
+        Label player3name = new Label("Player 3");
+        Label player4name = new Label("Player 4");
+        player1name.setTextFill(Color.WHITE);
+        player2name.setTextFill(Color.WHITE);
+        player3name.setTextFill(Color.WHITE);
+        player4name.setTextFill(Color.WHITE);
+        VBox playernames = new VBox();
+        player1 = new TextField();
+        player2 = new TextField();
+        player3 = new TextField();
+        player4 = new TextField();
+        player2.setDisable(true);
+        player3.setDisable(true);
+        player4.setDisable(true);
+        playerLabels.setLayoutX(355);
+        playerLabels.setLayoutY(300);
+        playerLabels.setSpacing(30);
+        playerLabels.getChildren().addAll(player1name,player2name,player3name,player4name);
+        playernames.setLayoutX(415);
+        playernames.setLayoutY(300);
+        playernames.getChildren().addAll(player1,player2,player3,player4);
+        /*Limit the name field to 9 characters*/
+        player1.setOnKeyTyped(event ->{
+            int maxCharacters = 8;
+            if(player1.getText().length() > maxCharacters) event.consume();
+        });
+        player2.setOnKeyTyped(event ->{
+            int maxCharacters = 8;
+            if(player2.getText().length() > maxCharacters) event.consume();
+        });
+        player3.setOnKeyTyped(event ->{
+            int maxCharacters = 8;
+            if(player3.getText().length() > maxCharacters) event.consume();
+        });
+        player4.setOnKeyTyped(event ->{
+            int maxCharacters = 8;
+            if(player4.getText().length() > maxCharacters) event.consume();
+        });
+        playernames.setSpacing(20);
+        player.setMaxSize(200,200);
+        introroot.getChildren().add(playernames);
+        introroot.getChildren().add(playerLabels);
+        root.getChildren().add(controls);
+        root.getChildren().add(playerIDs);
+  //      root.getChildren().add(flags);
+        root.getChildren().add(winnerID);
+        root.getChildren().add(declareWinner);
+        root.getChildren().add(sounds);
+        root.getChildren().addAll(p1Score,p2Score,p3Score,p4Score);
+        root.getChildren().add(scoreHead);
+        root.getChildren().addAll(flagCount,cardCount);
+        scene1player.setVolume(0.2);
+        scene1player.play();
+        introroot.getChildren().add(player);
+        introroot.getChildren().add(startGame);
+        introroot.getChildren().add(help);
+
+        /*based on the selection of number of players enable or disable the textfields for names*/
+        player.setOnAction(new EventHandler<ActionEvent>() {
+            @Override
+            public void handle(ActionEvent event) {
+                if(player.getValue() == "1 Player")
+                {
+                    player2.setDisable(true);
+                    player3.setDisable(true);
+                    player4.setDisable(true);
+                }
+                if(player.getValue() == "2 Players")
+                {
+                    player2.setDisable(false);
+                    player3.setDisable(true);
+                    player4.setDisable(true);
+                }
+                else if(player.getValue() == "3 Players")
+                {
+                    player2.setDisable(false);
+                    player3.setDisable(false);
+                    player4.setDisable(true);
+                }
+                else if(player.getValue() == "4 Players")
+                {
+                    player2.setDisable(false);
+                    player3.setDisable(false);
+                    player4.setDisable(false);
+                }
+            }
+        });
+        playerName = new String[4];
+        playerName[0] = "Player 1";
+        playerName[1] = "Player 2";
+        playerName[2] = "Player 3";
+        playerName[3] = "Player 4";
+        sp1.setText("Player 1");
+        sp2.setText("Player 2");
+        sp3.setText("Player 3");
+        sp4.setText("Player 4");
+        /*Initialization and setting up of steps when the game starts*/
+        startGame.setOnAction(new EventHandler<ActionEvent>() {
+            @Override
+            public void handle(ActionEvent e) {
+                createGrid();
+                click1.play();
+                scene1player.stop();// Stop scene 1 music
+                lokiIntro.play(); // Play intro Loki message
+                scene2player.setVolume(0.1); //Reduce the volume
+                scene2player.play();//Start scene 2 music
+                num_players = Integer.parseInt(player.getValue().toString().substring(0,1));
+                if(!player1.getText().equals("")) {
+                    playerName[0] = player1.getText();
+                    sp1.setText(playerName[0]);
+                }
+                /*Based on the number of players adjust the position of Scores title and the names displayed*/
+                if(num_players == 1)
+                {
+                    playerName[1] = "Omega(AI)";
+                    num_players = 2;
+                    sp2.setText("Omega(AI)");
+                    sp3.setText(" ");
+                    sp4.setText(" ");
+                    scoreHead.setLayoutX(714);
+                    scoreHead.setLayoutY(435);
+                }
+                if(num_players == 2)
+                {
+                    sp3.setText(" ");
+                    sp4.setText(" ");
+                    scoreHead.setLayoutX(714);
+                    scoreHead.setLayoutY(435);
+                    if(!player2.getText().equals("")) {
+                        playerName[1] = player2.getText();
+                        sp2.setText(playerName[1]);
+                    }
+                }
+                if(num_players == 3)
+                {
+                    sp4.setText(" ");
+                    scoreHead.setLayoutX(742);
+                    scoreHead.setLayoutY(435);
+                    if(!player2.getText().equals("") || !player3.getText().equals("")) {
+                        playerName[1] = player2.getText();
+                        playerName[2] = player3.getText();
+                        sp2.setText(playerName[1]);
+                        sp3.setText(playerName[2]);
+                    }
+                }
+                if(num_players == 4)
+                {
+                    scoreHead.setLayoutX(772);
+                    scoreHead.setLayoutY(435);
+                    if(!player2.getText().equals("") || !player3.getText().equals("") || !player4.getText().equals("")) {
+                        playerName[1] = player2.getText();
+                        playerName[2] = player3.getText();
+                        playerName[3] = player4.getText();
+                        sp2.setText(playerName[1]);
+                        sp3.setText(playerName[2]);
+                        sp4.setText(playerName[3]);
+                    }
+                }
+                /*Initialize the gains per person to start*/
+                for(String s:roundGains)
+                {
+                    s = " ";
+                }
+                /*Used to toggle the music controls*/
+                mutemusic.setOnAction(new EventHandler<ActionEvent>() {
+                    @Override
+                    public void handle(ActionEvent event) {
+                        if(scene2player.isPlaying())
+                        {
+                            scene2player.stop();
+                        }
+                        else
+                            scene2player.play();
+                    }
+                });
+                playerIDs.getChildren().addAll(p1);
+                setup();
+                textField.clear();
+                qinF.setLayoutX(743);
+                qinF.setLayoutY(60);
+                qiF.setLayoutX(743);
+                qiF.setLayoutY(115);
+                chuF.setLayoutX(743);
+                chuF.setLayoutY(165);
+                zhaoF.setLayoutX(743);
+                zhaoF.setLayoutY(239);
+                hanF.setLayoutX(743);
+                hanF.setLayoutY(295);
+                weiF.setLayoutX(743);
+                weiF.setLayoutY(342);
+                yanF.setLayoutX(743);
+                yanF.setLayoutY(383);
+                root.getChildren().addAll(qinF,qiF,chuF,zhaoF,hanF,weiF,yanF);
+                setup = placement1;
+                boardMatrix = createMatrix(placement1);
+                primaryStage.setScene(scene);
+            }
+        });
+
+        /* Create the help screen with instructions to play the game*/
+        help.setOnAction(new EventHandler<ActionEvent>() {
+            @Override
+            public void handle(ActionEvent event) {
+                final Stage helpScreen = new Stage();
+                helpScreen.getIcons().add(new Image("/resource/comicwars.jpg"));
+                helpScreen.setResizable(false);
+                Image helpS = new Image("/resource/z11_background.jpg");
+                helpScreen.initModality(Modality.APPLICATION_MODAL);
+                helpScreen.initOwner(primaryStage);
+                Pane insts = new Pane();
+                Scene dialogScene = new Scene(insts, 1300, 730);
+                insts.setBackground(new Background(new BackgroundImage(helpS,
+                        BackgroundRepeat.NO_REPEAT, BackgroundRepeat.NO_REPEAT,
+                        BackgroundPosition.CENTER,
+                        new BackgroundSize(BackgroundSize.AUTO, BackgroundSize.AUTO, false, false, true, true))));
+                helpScreen.setScene(dialogScene);
+                helpScreen.show();
+            }
+        });
+        makeControls();
+        primaryStage.setResizable(false);
+        primaryStage.setScene(intro);
+        primaryStage.getIcons().add(new Image("/resource/comicwars.jpg"));
+        primaryStage.show();
+
+    }
+
+    /**
+     * Create the layout grid for move reference
+     * Author: Rufus Raja (u6275198)
+     */
+    public void createGrid()
+    {
+        String array[][] = {
+                {"4","5","6","7","8","9"},
+                {"Y","Z","0","1","2","3"},
+                {"S","T","U","V","W","X"},
+                {"M","N","O","P","Q","R"},
+                {"G","H","I","J","K","L"},
+                {"A","B","C","D","E","F"}
+        };
+        Label setupDisplay = new Label("Board Layout = ");
+        setupDisplay.setLayoutX(638);
+        setupDisplay.setLayoutY(610);
+        setupDisplay.setTextFill(Color.WHITE);
+        setupDisplay.setFont(Font.font("Verdana", FontWeight.BOLD, 12));
+        pane.setLayoutX(750);
+        pane.setLayoutY(560);
+        pane.setStyle("-fx-background-color: Black; -fx-border-color: Black");
+        root.getChildren().add(pane);
+        root.getChildren().add(setupDisplay);
+        for (int x = 0; x < array.length; x++){
+            for (int y = 0; y < array[x].length; y++){
+                Label label = new Label(array[x][y], new Rectangle(8, 8));
+                label.setTextFill(Color.WHITE);
+                label.setFont(Font.font("Verdana", FontWeight.BOLD, 14));
 
+                pane.add(label, x, y);
+            }
+        }
     }
-}
 
+    /**
+     * Count the number of flags and cards of each player, decide who is the winner
+     * Author: Rufus Raja (u6275198), Jiajia Xu (6528982)
+     */
+    public static void winner() {
+        int playerSums [] = new int[num_players];
+        for(int x=0; x<playerSums.length;x++)
+        {
+            playerSums[x] = WinnerSum(x);
+        }
+        int max = playerSums[0];
+        winner = 0;
+        String winnerName = " ";
+        /*Compare number of flags to determine the winner*/
+        for(int x=0;x<playerSums.length;x++)
+        {
+            if(playerSums[x] > max)
+            {
+                max=playerSums[x];
+                winner= x;
+
+            }
+            if(playerSums[x] == max)
+            {
+                /*If the flags are same, checks for the number of cards*/
+                if(cardCount[x] > cardCount[winner]) {
+                    max = playerSums[x];
+                    winner = x;
+                }
+                /*If cards are same checks for who holds the Avengers cards (largest team)*/
+                if(cardCount[x] == cardCount[winner] && flag[0] == x)
+                {
+                    winner = x;
+                }
+                else
+                {
+                    continue;
+                }
+            }
+        }
+        winnerName = playerName[winner];
+        String win = Integer.toString(winner);
+        Game end = new Game();
+        declareWinner.setText("Player "+winnerName+" is the Winner!");
+        end.scene2player.setVolume(0.08);
+        end.lokiEnding.play();
+        end.scene2player.stop();
+        declareWinner.setLayoutX(0);
+        declareWinner.setLayoutY(0);
+        declareWinner.setFont(Font.font("Verdana", FontWeight.BOLD, 50));
+        declareWinner.setFill(Color.RED);
+
+
+
+    }
+
+    /**
+     * Method to find the sum of flags held by a player ID
+     * @param id
+     * @return
+     */
+    public static int WinnerSum(int id)
+    {
+        int sum = 0;
+        for(int x=0;x<flag.length;x++)
+        {
+            if(flag[x] == id)
+            {
+                sum+=1;
+            }
+        }
+        return sum;
+    }
+
+    /**
+     * Create the initial setup for the board
+     * Author: Rufus Raja (u6275198)
+     */
+    public void setup() {
+        int rown = 0, coln = 0,col=5;
+        Random r = new Random();
+        int selector = r.nextInt(20);
+        Image[][] grid = new Image[6][6];
+        placement1 = PLACEMENTS[selector];
+        String [] sub = substr(placement1,3);
+        scores1.setText(" ");
+        scores2.setText(" ");
+        scores3.setText(" ");
+        scores4.setText(" ");
+        /*Loop through and check the positions for each image and store them to the image array*/
+        for (int y = 0; y < sub.length; y++) {
+            if (sub[y].charAt(0) == 'z') {
+                rown = 7;
+                coln = 0;
+            } else {
+                rown = sub[y].charAt(0) - 'a';
+                coln = sub[y].charAt(1) - '0';
+            }
+            if (sub[y].charAt(2) >= 65 && sub[y].charAt(2) <= 70) {
+                int row = sub[y].charAt(2) % 13;
+                grid[row][col] = grid2[rown][coln];
+            }
+            if (sub[y].charAt(2) >= 71 && sub[y].charAt(2) <= 76) {
+                int row = (sub[y].charAt(2) % 71) ;
+                grid[row][col-1] = grid2[rown][coln];
+            }
+            if (sub[y].charAt(2) >= 77 && sub[y].charAt(2) <= 82) {
+                int row = (sub[y].charAt(2) % 77) ;
+                grid[row][col-2] = grid2[rown][coln];
+            }
+            if (sub[y].charAt(2) >= 83 && sub[y].charAt(2) <= 88) {
+                int row = (sub[y].charAt(2) % 83) ;
+                grid[row][col-3] = grid2[rown][coln];
+            }
+            if (sub[y].charAt(2) >= 89 && sub[y].charAt(2) <= 90) {
+                int row = (sub[y].charAt(2) % 89);
+                grid[row][col-4] = grid2[rown][coln];
+            }
+            if (sub[y].charAt(2) >= 48 && sub[y].charAt(2) <= 51) {
+                int row = (sub[y].charAt(2) % 23);
+                grid[row][col-4] = grid2[rown][coln];
+            }
+            if (sub[y].charAt(2) >= 52 && sub[y].charAt(2) <= 57) {
+                int row = (sub[y].charAt(2) % 52);
+                grid[row][col-5] = grid2[rown][coln];
+            }
+        }
+        gridPane.setHgap(2);
+        gridPane.setVgap(2);
+        gridPane.setStyle("-fx-background-color: Black; -fx-border-color: Black");
+        gridPane.setPadding(new Insets(1,1,1,1));
+        for (int x = 0; x < grid.length; x++) {
+            for (int y = 0; y < grid[x].length; y++) {
+                ImageView imageView = new ImageView(grid[x][y]);
+                imageView.setFitWidth(100);
+                imageView.setFitHeight(100);
+                gridPane.add(imageView, y, x);
+            }
+        }
+    }
+
+
+    /**
+     * Method to carry out the next step after a player or the bot has selected a position to move to
+     * Authors: Rufus Raja (u6275198), Songtuan Lin (u6162630)
+     */
+    public void nextStep() {
+        String move = "z9"+getMove;
+        boolean isEnd = true;
+        if(!getMove.equals("")) {
+            check = isMoveLegal(placement1, getMove.charAt(0));
+            if (check) {
+                boardMatrix = oneMove(move.charAt(2), placement1, boardMatrix);
+                placement1 = matrixToString(boardMatrix);
+                gridPane.getChildren().clear();
+                boolean validPlacement = isPlacementWellFormed(placement1);
+                if (validPlacement) {
+                    makePlacement(placement1);
+                } else
+                    exit();
+                moveSequence = moveSequence + getMove;
+                int score1,score2,score3,score4;
+                score1=score2=score3=score4=0;
+                flag = getFlags(setup, moveSequence, num_players);
+                /*Counts the number of flags and cards for a player*/
+                for (int i = 0; i < flag.length; i++) {
+                    if (flag[i] == -1) {
+                        roundGains[i] = " ";
+                    } else if (flag[i] == 0) {
+                        cardCount[flag[i]] = numOfCards(flag[i]);
+                        roundGains[i] = playerName[flag[i]];//+" ("+cardCount[flag[i]]+")";
+                        score1+=1;
+                    } else if (flag[i] == 1) {
+                        cardCount[flag[i]] = numOfCards(flag[i]);
+                        roundGains[i] = playerName[flag[i]];//+" ("+cardCount[flag[i]]+")";
+                        score2+=1;
+                    } else if (flag[i] == 2) {
+                        cardCount[flag[i]] = numOfCards(flag[i]);
+                        roundGains[i] = playerName[flag[i]];//+" ("+cardCount[flag[i]]+")";
+                        score3+=1;
+                    } else if (flag[i] == 3) {
+                        cardCount[flag[i]] = numOfCards(flag[i]);
+                        roundGains[i] = playerName[flag[i]];//+" ("+cardCount[flag[i]]+")";
+                        score4+=1;
+                    }
+                }
+
+                /*Displays the scores for each player*/
+                if(score1 != 0){
+                    scores1.setText(" "+Integer.toString(score1));
+                    cards1.setText(" "+Integer.toString(cardCount[0]));
+                }
+                if(score2 != 0){
+                    scores2.setText(" "+Integer.toString(score2));
+                    cards2.setText(" "+Integer.toString(cardCount[1]));
+                }
+                if(score3 != 0){
+                    scores3.setText(" "+Integer.toString(score3));
+                    cards3.setText(" "+Integer.toString(cardCount[2]));
+                }
+                if(score4 != 0){
+                    scores4.setText(" "+Integer.toString(score4));
+                    cards4.setText(" "+Integer.toString(cardCount[3]));
+                }
+
+                qinF.setText(roundGains[0]);
+                qiF.setText(roundGains[1]);
+                chuF.setText(roundGains[2]);
+                zhaoF.setText(roundGains[3]);
+                hanF.setText(roundGains[4]);
+                weiF.setText(roundGains[5]);
+                yanF.setText(roundGains[6]);
+
+
+            }
+        }
+        else
+            check = false;
+
+        /*Check if there are any legal moves, if there are then continue game, else set the game for end sequence*/
+        for(int y=0;y<c.length;y++)
+            if(isMoveLegal(placement1,c[y]))
+                isEnd = false;
+
+        /*If the game is still going on, keep the music playing*/
+        if(!isEnd && !scene2player.isPlaying())
+            scene2player.play();
+
+        /*If the game end has been reached, start the winner declaration process*/
+        if(isEnd == true) {
+            winner();
+            botPlay = false;
+        }
+
+    }
+
+    /**
+     * Counts the number of cards based on the player ID
+     * @param id
+     * @return
+     * Author: Rufus Raja (u6275198)
+     */
+    private int numOfCards(int id) {
+        String supporters = getSupporters(setup,moveSequence,num_players,id);
+        String numofcards[] = new String[supporters.length()];
+        numofcards = substr(supporters,2);
+        return numofcards.length;
+    }
+
+    /**
+     * Advanced AI search for best move available
+     * @param placement
+     * @param boardState
+     * @return
+     * Author: Songtuan Lin (u6162630)
+     */
+    char alpha_beta_search(String placement, String[][] boardState)
+    {
+        List<Character> moveList = WarringStatesGame.LegalMoves(placement);
+        String nextState[][];
+        String nextPlacement;
+        int deep = 0;
+        int finalValue = -1000;
+        int value;
+        int alpha = -1000, beta = 1000; //the beta store the best score (the lowest value) that the most up min node which is current in calculating can get.
+        //the alpha store the best score (the highest value) that the most up max node which is current in calculating can get.
+        char nextMove = 'A';
+        boolean limit = true;
+        if(placement.length() < 66)
+            limit = false;
+        for(char move : moveList)
+        {
+            String newMovesequence = this.moveSequence + move;
+            nextState = WarringStatesGame.oneMoveGame(move, placement, boardState);
+            nextPlacement = WarringStatesGame.matrixToString(nextState);
+            value = min_value(nextPlacement, nextState, newMovesequence, alpha, beta, deep + 1, limit);
+            if(finalValue < value)
+            {
+                finalValue = value;
+                nextMove = move;
+            }
+        }
+        return nextMove;
+    }
+
+    /**
+     * Returns the minimum value based on the minimax algorithm
+     * @param placement
+     * @param boardState
+     * @param oldMoveSequence
+     * @param alpha
+     * @param beta
+     * @param deep
+     * @param limit
+     * @return
+     * Author: Songtuan Lin (u6162630)
+     */
+    int min_value(String placement, String[][] boardState, String oldMoveSequence, int alpha, int beta, int deep, boolean limit)
+    {
+        int minValue = 1000;
+        int value;
+        List<Character> moveList = WarringStatesGame.LegalMoves(placement);
+        String nextState[][];
+        String nextPlacement;
+        if(moveList.size() == 0)
+            return getUtility(oldMoveSequence);
+        else if(deep > 8 && limit == true)
+            return getUtility(oldMoveSequence);
+        for(char move : moveList)
+        {
+            String newMovesequence = oldMoveSequence + move;
+            nextState = WarringStatesGame.oneMoveGame(move, placement, boardState);
+            nextPlacement = WarringStatesGame.matrixToString(nextState);
+            value = max_value(nextPlacement, nextState, newMovesequence, alpha, beta, deep + 1, limit);
+            if(value <= alpha)
+                //if the one of the value (say y in this example) this min node get is smaller than the alpha
+                //then, the value domain of this node is [some value smaller than y]
+                //which means there is some better score for a upper max node can choose whose score is greater
+                //than y. As a result, the subtree that after this min node will not be choosed by the upper max
+                //node, the search after this node can be terminated.
+                return value;
+            if(value < minValue)
+                minValue = value;
+            if(value < beta)
+                beta = value;
+        }
+        return minValue;
+    }
+
+    /**
+     * Return the max value based on the minimax algorithm
+     * @param placement
+     * @param boardState
+     * @param oldMovesequence
+     * @param alpha
+     * @param beta
+     * @param deep
+     * @param limit
+     * @return
+     * Author: Songtuan Lin (u6162630)
+     */
+    int max_value(String placement, String[][] boardState, String oldMovesequence, int alpha, int beta, int deep, boolean limit)
+    {
+        int maxValue = -1000;
+        int value;
+        List<Character> moveList = WarringStatesGame.LegalMoves(placement);
+        String nextState[][];
+        String nextPlacement;
+        if(moveList.size() == 0)
+            return getUtility(oldMovesequence);
+        else if(deep > 8 && limit == true)
+            return getUtility(oldMovesequence);
+        for(char move : moveList)
+        {
+            String newMovesequence = oldMovesequence + move;
+            nextState = WarringStatesGame.oneMoveGame(move, placement, boardState);
+            nextPlacement = WarringStatesGame.matrixToString(nextState);
+            value = min_value(nextPlacement, nextState, newMovesequence, alpha, beta, deep + 1, limit);
+            if(value >= beta)
+                //if the one of the value (say x in this example) this max node get is greater than the beta
+                //then, the value domain of this node is [x, some value greater than x]
+                //which means there is some better score for a upper min node can choose whose score is smaller
+                //than x. As a result, the subtree that after this max node will not be choosed by the upper min
+                //node, the search after this node can be terminated.
+                return value;
+            if(value > maxValue)
+                maxValue = value;
+            if(value > alpha)
+                alpha = value;
+        }
+        return maxValue;
+    }
+
+    /**
+     * Checks the results based on the movesequence
+     * @param moveSequence
+     * @return
+     * Author: Songtuan Lin (u6162630)
+     */
+    int getUtility(String moveSequence)
+    {
+        int flag[] = WarringStatesGame.getFlags(this.setup, moveSequence, 2);
+        int flagNumber = 0;
+        int cardNumber = 0;
+        int utility = 0;
+        for(int i = 0; i < flag.length; i++)
+            if(flag[i] == 1)
+                flagNumber++;
+        cardNumber = WarringStatesGame.getSupporters(this.setup, moveSequence, 2, 1).length() / 2;
+        utility = flagNumber * 10 + cardNumber;
+        return utility;
+    }
+
+
+}
\ No newline at end of file
Only in comp1110-ass2/src/comp1110/ass2/gui: Viewer$1.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Viewer.class
diff -ru -x .git ../master/comp1110-ass2/src/comp1110/ass2/gui/Viewer.java comp1110-ass2/src/comp1110/ass2/gui/Viewer.java
--- ../master/comp1110-ass2/src/comp1110/ass2/gui/Viewer.java	2018-05-18 08:54:16.593376370 +1000
+++ comp1110-ass2/src/comp1110/ass2/gui/Viewer.java	2018-05-18 10:03:56.911249604 +1000
@@ -1,13 +1,18 @@
 package comp1110.ass2.gui;
 
+import comp1110.ass2.Card;
 import javafx.application.Application;
 import javafx.event.ActionEvent;
 import javafx.event.EventHandler;
+import javafx.geometry.Insets;
 import javafx.scene.Group;
 import javafx.scene.Scene;
 import javafx.scene.control.Button;
 import javafx.scene.control.Label;
 import javafx.scene.control.TextField;
+import javafx.scene.image.Image;
+import javafx.scene.image.ImageView;
+import javafx.scene.layout.GridPane;
 import javafx.scene.layout.HBox;
 import javafx.stage.Stage;
 
@@ -18,7 +23,9 @@
  * class does not play a game, it just illustrates various card placements.
  */
 public class Viewer extends Application {
+    Card p = new Card();                                                //creating an object of the card class to display the cards.
 
+    GridPane gridPane = new GridPane();
     private static final int VIEWER_WIDTH = 933;
     private static final int VIEWER_HEIGHT = 700;
 
@@ -34,8 +41,104 @@
      * @param placement A valid placement string
      */
     void makePlacement(String placement) {
+
+        //example String for testing : "a2Aa3Gc4Hb5Ed0Sg04g19e02a7Uz0V"
         // FIXME Task 4: implement the simple placement viewer
-    }
+      //  boolean a = WarringStatesGame.isCardPlacementWellFormed(placement);
+
+            String sub[] = new String[placement.length() / 3];
+            int rown = 0, coln = 0,col=5;
+            Image[][] grid = new Image[6][6];
+
+    //Creating a grid of images to be used.
+        Image[][] grid2 =
+                {
+                        {p.a0, p.a1, p.a2, p.a3, p.a4, p.a5, p.a6, p.a7},
+                        {p.b0, p.b1, p.b2, p.b3, p.b4, p.b5, p.b6},
+                        {p.c0, p.c1, p.c2, p.c3, p.c4, p.c5},
+                        {p.d0, p.d1, p.d2, p.d3, p.d4},
+                        {p.e0, p.e1, p.e2, p.e3},
+                        {p.f0, p.f1, p.f2},
+                        {p.g0, p.g1},
+                        {p.z9}
+                };
+
+            sub = substr(placement);
+
+    // Checking the position based on the placement string and assigning the images to the board.
+            for (int y = 0; y < sub.length; y++) {
+                if (sub[y].charAt(0) == 'z') {
+                    rown = 7;
+                    coln = 0;
+                } else {
+                    rown = sub[y].charAt(0) - 'a';
+                    coln = sub[y].charAt(1) - '0';
+                }
+                if (sub[y].charAt(2) >= 65 && sub[y].charAt(2) <= 70) {
+                    int row = sub[y].charAt(2) % 13;
+                    grid[row][col] = grid2[rown][coln];
+                }
+                if (sub[y].charAt(2) >= 71 && sub[y].charAt(2) <= 76) {
+                    int row = (sub[y].charAt(2) % 71) ;
+                    grid[row][col-1] = grid2[rown][coln];
+                }
+                if (sub[y].charAt(2) >= 77 && sub[y].charAt(2) <= 82) {
+                    int row = (sub[y].charAt(2) % 77) ;
+                    grid[row][col-2] = grid2[rown][coln];
+                }
+                if (sub[y].charAt(2) >= 83 && sub[y].charAt(2) <= 88) {
+                    int row = (sub[y].charAt(2) % 83) ;
+                    grid[row][col-3] = grid2[rown][coln];
+                }
+                if (sub[y].charAt(2) >= 89 && sub[y].charAt(2) <= 90) {
+                    int row = (sub[y].charAt(2) % 89);
+                    grid[row][col-4] = grid2[rown][coln];
+                }
+                if (sub[y].charAt(2) >= 48 && sub[y].charAt(2) <= 51) {
+                    int row = (sub[y].charAt(2) % 23);
+                    grid[row][col-4] = grid2[rown][coln];
+                }
+                if (sub[y].charAt(2) >= 52 && sub[y].charAt(2) <= 57) {
+                    int row = (sub[y].charAt(2) % 52);
+                    grid[row][col-5] = grid2[rown][coln];
+                }
+
+
+            }
+
+    //Setting the gridpane structure with the veritical and horizontal distances.
+            gridPane.setHgap(2);
+            gridPane.setVgap(2);
+            gridPane.setStyle("-fx-background-color: White; -fx-border-color: Black ");
+            gridPane.setPadding(new Insets(1,1,1,1));
+            for (int x = 0; x < grid.length; x++) {
+                for (int y = 0; y < grid[x].length; y++) {
+                    ImageView imageView = new ImageView(grid[x][y]);
+                    imageView.setFitWidth(100);
+                    imageView.setFitHeight(100);
+                    gridPane.add(imageView, y, x);
+                }
+            }
+
+        }
+
+    /**
+     * @param placement
+     * @return array of strings containing each character and it's position
+     * Author: Rufus Raja (u6275198)
+     */
+    public String[] substr(String placement)
+        {
+            int count =0;
+            String sub[] = new String[placement.length()/3];
+            for (int x = 0; x < placement.length(); x += 3) {
+                sub[count] = placement.substring(x, x + 3);
+                count++;
+            }
+            return sub;
+        }
+
+
 
     /**
      * Create a basic text field for input and a refresh button.
@@ -48,6 +151,7 @@
         button.setOnAction(new EventHandler<ActionEvent>() {
             @Override
             public void handle(ActionEvent e) {
+                gridPane.getChildren().clear();
                 makePlacement(textField.getText());
                 textField.clear();
             }
@@ -62,14 +166,24 @@
 
     @Override
     public void start(Stage primaryStage) throws Exception {
+
+
         primaryStage.setTitle("Warring States Viewer");
-        Scene scene = new Scene(root, VIEWER_WIDTH, VIEWER_HEIGHT);
 
+        gridPane.setLayoutX(100);
+        gridPane.setLayoutY(10);
+
+        root.getChildren().add(gridPane);
+
+        Scene scene = new Scene(root, VIEWER_WIDTH, VIEWER_HEIGHT);
         root.getChildren().add(controls);
 
-        makeControls();
 
+        makeControls();
         primaryStage.setScene(scene);
         primaryStage.show();
+
     }
 }
+
+
Only in comp1110-ass2/src/comp1110/ass2: Kingdom.class
Only in comp1110-ass2/src/comp1110/ass2: Kingdom.java
Only in comp1110-ass2/src/comp1110/ass2: Player.class
Only in comp1110-ass2/src/comp1110/ass2: Player.java
Only in comp1110-ass2/src/comp1110/ass2: WarringStatesGame.class
diff -ru -x .git ../master/comp1110-ass2/src/comp1110/ass2/WarringStatesGame.java comp1110-ass2/src/comp1110/ass2/WarringStatesGame.java
--- ../master/comp1110-ass2/src/comp1110/ass2/WarringStatesGame.java	2018-05-18 08:54:16.569376239 +1000
+++ comp1110-ass2/src/comp1110/ass2/WarringStatesGame.java	2018-05-18 10:03:56.887249476 +1000
@@ -1,10 +1,18 @@
 package comp1110.ass2;
 
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+
+import comp1110.ass2.gui.Viewer;
+
+
 /**
  * This class provides the text interface for the Warring States game
  */
 public class WarringStatesGame {
-
+//    public static Viewer v = new Viewer();
     /**
      * Determine whether a card placement is well-formed according to the following:
      * - it consists of exactly three characters
@@ -14,10 +22,72 @@
      *
      * @param cardPlacement A string describing a card placement
      * @return true if the card placement is well-formed
+     * author:Jiajia Xu
      */
-    static boolean isCardPlacementWellFormed(String cardPlacement) {
+      static boolean isCardPlacementWellFormed(String cardPlacement) {
         // FIXME Task 2: determine whether a card placement is well-formed
-        return false;
+          //check the length is 3
+        if(cardPlacement.length()!=3){
+            return false;
+        }
+        // check the first character is in range
+        if( ! ( ( cardPlacement.charAt(0)>='a'&& cardPlacement.charAt(0)<='g') || ( cardPlacement.charAt(0)=='z') )  ){
+            return false;
+        }
+        // check the second character is in range
+        switch(cardPlacement.charAt(0)){
+                case 'a':
+                    if(cardPlacement.charAt(1)< '0' ||cardPlacement.charAt(1)>'7'){
+                        return false;
+                        }
+                    break;
+                case 'b':
+                    if(cardPlacement.charAt(1)< '0' ||cardPlacement.charAt(1)>'6'){
+                        return false;
+                    }
+                    break;
+                case 'c':
+                    if(cardPlacement.charAt(1)< '0' ||cardPlacement.charAt(1)>'5'){
+                        return false;
+                    }
+                    break;
+                case 'd':
+                    if(cardPlacement.charAt(1)< '0' ||cardPlacement.charAt(1)>'4'){
+                        return false;
+                    }
+                    break;
+                case 'e':
+                    if(cardPlacement.charAt(1)< '0' ||cardPlacement.charAt(1)>'3'){
+                        return false;
+                    }
+                    break;
+                case 'f':
+                    if(cardPlacement.charAt(1)< '0' ||cardPlacement.charAt(1)>'2'){
+                        return false;
+                    }
+                    break;
+                case 'g':
+                    if(cardPlacement.charAt(1)< '0' ||cardPlacement.charAt(1)>'1'){
+                        return false;
+                    }
+                    break;
+                case 'z':
+                    if(cardPlacement.charAt(1)!='9'){
+                        return false;
+                    }
+                    break;
+            }
+            // check the Location character is in range
+        if(! ( (cardPlacement.charAt(2)>='A'&& cardPlacement.charAt(2)<='Z') ||(cardPlacement.charAt(2)>='0'&& cardPlacement.charAt(2)<='9') )  ){
+                return false;
+            }
+        else
+            {return true;}
+
+
+
+
+
     }
 
     /**
@@ -29,12 +99,43 @@
      *
      * @param placement A string describing a placement of one or more cards
      * @return true if the placement is well-formed
+     * Author: Jiajia Xu
      */
-    static boolean isPlacementWellFormed(String placement) {
+    public static boolean isPlacementWellFormed(String placement) {
         // FIXME Task 3: determine whether a placement is well-formed
-        return false;
+        //avoid null pointer exception and make sure the length is qualified
+        if(placement==null||placement.equals("")||placement.length()%3!=0||placement.length()/3<1 || placement.length()/3>36){
+            return false;
+        }
+        //check each card is well formed and no same cards
+        for(int i=0;i<placement.length();i+=3) {
+            if (!isCardPlacementWellFormed(placement.substring(i,i+3))){
+                return false;
+                }
+
+            for(int j=0;j<placement.length();j+=3){
+                if(i!=j){
+                    if(placement.substring(i,i+2).equals(placement.substring(j,j+2))){
+                        return false;
+                    }
+                    if(placement.charAt(i+2)==placement.charAt(j+2)){
+                        return false;
+                    }
+                }
+            }
+        }
+
+        return true;
     }
 
+
+
+    /*public static void main(String[] args) {
+        isPlacementWellFormed("f0Mc4M");
+
+    }*/
+
+
     /**
      * Determine whether a given move is legal given a provided valid placement:
      * - the location char is in the range A .. Z or 0..9
@@ -46,12 +147,178 @@
      * @param placement    the current placement string
      * @param locationChar a location for Zhang Yi to move to
      * @return true if Zhang Yi may move to that location
+     * Author: Garrick Lin
      */
     public static boolean isMoveLegal(String placement, char locationChar) {
         // FIXME Task 5: determine whether a given move is legal
+        int locationCor[] = new int[2];
+        int zhangLoc[] = new int[2];
+        locationCor = transformCor(locationChar);//transform the destination location from char to a 2D index
+        zhangLoc = transformCor(zLocation(placement));//transform ZhangYi's location to 2D index
+        if(!((locationChar >= 'A' && locationChar <= 'Z') || (locationChar >= '0' && locationChar <= '9')))
+            //check whether the destination is a leagal location
+            return false;
+        else if(zhangLoc[0] != locationCor[0] && zhangLoc[1] != locationCor[1])
+            //check whether destination is in the line with ZhangYi's location by checking
+            //whether the row index or column index is equal
+            return false;
+        else if(isEmptyLoc(placement, locationChar))
+            //check whether the destination is empty with card
+            return false;
+        else if(!isFarestCard(placement, zhangLoc, locationCor))
+            //check whether the destination is the farest card with it's kingdom
+            return false;
+        else if(locationChar == zLocation(placement))
+            return false;
+        return true;
+    }
+
+    static boolean isFarestCard(String placement, int[] zhangLoc, int[] locationCor)
+    {
+        char charLoc;
+        char kingdom = getKingdom(corTochar(locationCor[1], locationCor[0]), placement);//get the kingdom in destination location
+        if(zhangLoc[0] == locationCor[0])
+        {
+            //if destination is in the same row with ZhangYi
+            if(zhangLoc[1] > locationCor[1])
+            {
+                //start from destination location to boundary location
+                for(int i = locationCor[1] - 1; i >= 0; i--)
+                {
+                    //transform each 2D index back into char location
+                    //check whether the kingdom in this location is same as kingdom in destination location
+                    charLoc = corTochar(i, locationCor[0]);
+                    if(isSameKingdom(kingdom, placement, charLoc))
+                        return false;
+                }
+            }
+            else if(zhangLoc[1] < locationCor[1])
+            {
+                for(int i = locationCor[1] + 1; i < 6; i++)
+                {
+                    charLoc = corTochar(i, locationCor[0]);
+                    if(isSameKingdom(kingdom, placement, charLoc))
+                        return false;
+                }
+            }
+        }
+        else if(zhangLoc[1] == locationCor[1])
+        {
+            if(zhangLoc[0] > locationCor[0])
+            {
+                for(int i = locationCor[0] - 1; i >= 0; i--)
+                {
+                    charLoc = corTochar(locationCor[1], i);
+                    if(isSameKingdom(kingdom, placement, charLoc))
+                        return false;
+                }
+            }
+            else if(zhangLoc[0] < locationCor[0])
+            {
+                for(int i = locationCor[0] + 1; i < 6; i++)
+                {
+                    charLoc = corTochar(locationCor[1], i);
+                    if(isSameKingdom(kingdom, placement, charLoc))
+                        return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    public static char getKingdom(char location, String placement)
+    {
+        int offset = 3;
+        String sub = new String();
+        char kingdom = 'a';
+        for(int i = 0; i <= placement.length() - 3; i = i + offset)
+        {
+            sub = placement.substring(i, i + offset);
+            if(location == sub.charAt(2))
+                kingdom = sub.charAt(0);
+        }
+        return kingdom;
+    }
+
+    public static boolean isSameKingdom(char kingdom, String placement, char charLoc)
+    {
+        //given the traget location, target kingdom and placement string
+        //check whether the kingdom in target location is same as target kingdom
+        int offset = 3;
+        String sub = new String();
+        for(int i = 0; i <= placement.length() - 3; i = i + offset)
+        {
+            //search for the whole placement string, split each card placement string(3 characters)
+            //compare each card's location with target location//
+            //if equal, check whether the target kingdom is equal to this kingdom
+            sub = placement.substring(i, i + offset);
+            if(charLoc == sub.charAt(2))
+                if(kingdom == sub.charAt(0))
+                    return true;
+        }
         return false;
     }
 
+    static boolean isEmptyLoc(String placement, char locationChar)
+    {
+        //check whether target location is an empty location by checking
+        //whether target char location is in placement string
+        int offset = 3;
+        for(int i = 2; i < placement.length(); i = i + offset)
+        {
+            if(locationChar == placement.charAt(i))
+                return false;
+        }
+        return true;
+    }
+
+    public static int[] transformCor(char locationChar)
+    {
+        //transform char location to 2D index
+        int locationCor[] = {0, 0};
+        if(locationChar >= 'A' && locationChar <= 'Z')
+        {
+            int index = locationChar - 65;
+            //locationCor[1] = (index / 6);
+            locationCor[1] = 5 - (index / 6);
+            locationCor[0] = index % 6;
+        }
+        else if(locationChar >= '0' && locationChar <= '9')
+        {
+            int index = 26 + (locationChar - 48);
+            //locationCor[1] = (index / 6);
+            locationCor[1] = 5 - (index / 6);
+            locationCor[0] = index % 6;
+        }
+        return locationCor;
+    }
+
+    static char corTochar(int column, int row)
+    {
+        //transform 2D index back into char location
+        column = 5 - column;
+        int index = column * 6 + row;
+        char ch = 'A';
+        if(index <= 25)
+            ch = (char)(65 + index);
+        else if(index > 25 && index <= 35)
+            ch = (char)(index - 1 - 25 + 48);
+        return ch;
+    }
+
+    static char zLocation(String placement)
+    {
+        //find ZhangYi's location
+        int offset = 3;
+        char location = 'A';
+        for(int i = 0; i <= placement.length() - offset; i = i + offset)
+        {
+            if(placement.charAt(i) == 'z')
+                location = placement.charAt(i + 2);
+        }
+        return location;
+    }
+
     /**
      * Determine whether a move sequence is valid.
      * To be valid, the move sequence must be comprised of 1..N location characters
@@ -62,10 +329,127 @@
      * @param setup        A placement string representing the board setup
      * @param moveSequence a string of location characters representing moves
      * @return True if the placement sequence is valid
+     * Author: Garrick Lin
      */
-    static boolean isMoveSequenceValid(String setup, String moveSequence) {
+    public static boolean isMoveSequenceValid(String setup, String moveSequence) {
         // FIXME Task 6: determine whether a placement sequence is valid
-        return false;
+        String boardMatrix[][] = new String[6][6];
+        String placement = setup;
+        boardMatrix = createMatrix(placement);
+        char moveSequenceChar[] = moveSequence.toCharArray();
+        for(int i = 0; i < moveSequence.length(); i++)
+        {
+            if(isMoveLegal(placement, moveSequenceChar[i]))
+            {
+                boardMatrix = oneMove(moveSequenceChar[i], placement, boardMatrix);
+                placement = matrixToString(boardMatrix);
+                int k = 0;
+            }
+            else
+                return false;
+        }
+        return true;
+    }
+
+    public static String[][] createMatrix(String placement)
+    {
+        //create a 6x6 matrix represent board, each element in this matrix is a
+        //character card
+        String boardMatrix[][] = new String[6][6];
+        int offset = 3;
+        int cor[] = new int[2];
+        for(int i = 0; i <= placement.length() - 3; i = i + offset)
+        {
+            cor = transformCor(placement.substring(i, i + 3).charAt(2));
+            boardMatrix[cor[0]][cor[1]] = placement.substring(i, i + 3).substring(0, 2);
+        }
+        return boardMatrix;
+    }
+
+    public static String matrixToString(String boardMatrix[][])
+    {
+        //convert matrix to placement string
+        int column, row;
+        char charLocation;
+        String placement = new String();
+        for(column = 5; column >= 0; column--)
+        {
+            for(row = 0; row <= 5; row++)
+            {
+                if(boardMatrix[row][column] != "")
+                {
+                    //if elemtn in matrix is "", which means
+                    //card has already been collected by player
+                    //do not add this place to placement string
+                    charLocation = corTochar(column, row);
+                    placement = placement + boardMatrix[row][column] + charLocation;
+                }
+            }
+        }
+        return placement;
+    }
+
+    public static String[][] oneMove(char charLocation, String placement, String[][] boardMatrix)
+    {
+        //change the board state according to current move char
+        //the parameter are follow:
+        //@charLocation: the destination location
+        //@placement: placement string
+        //boardMatrix: matrix represent current board state
+        //return a matrix that represent new board state after current move
+        int cor[] = transformCor(charLocation);
+        char zhangLocChar = zLocation(placement);
+        int zhangLocCor[] = transformCor(zhangLocChar);
+        char kingdom = getKingdom(charLocation, placement);
+        if(zhangLocCor[0] == cor[0])
+        {
+            //if destination location is in the same row as ZhangYi's location
+            if(zhangLocCor[1] > cor[1])
+            {
+                for(int col = zhangLocCor[1] - 1; col >= cor[1]; col--)
+                {
+                    //start from ZhangYi's location to destination location
+                    //determine whether this location has the same kingdom as destination location
+                    if(isSameKingdom(kingdom, placement, corTochar(col, zhangLocCor[0])))
+                        boardMatrix[zhangLocCor[0]][col] = "";
+                }
+            }
+            else if(zhangLocCor[1] < cor[1])
+            {
+                for(int col = zhangLocCor[1] + 1; col <= cor[1]; col++)
+                {
+                    if(isSameKingdom(kingdom, placement, corTochar(col, zhangLocCor[0])))
+                        //if the kindome is same, set the element in this location to ""
+                        boardMatrix[zhangLocCor[0]][col] = "";
+                }
+            }
+        }
+        else if(zhangLocCor[1] == cor[1])
+        {
+            //if destination location is in the same column as ZhangYi's location
+            if(zhangLocCor[0] > cor[0])
+            {
+                for(int row = zhangLocCor[0] - 1; row >= cor[0]; row--)
+                {
+                    //start from ZhangYi's location to destination location
+                    //determine whether this location has the same kingdom as destination location
+                    if(isSameKingdom(kingdom, placement, corTochar(zhangLocCor[1], row)))
+                        //if the kindome is same, set the element in this location to ""
+                        boardMatrix[row][zhangLocCor[1]] = "";
+                }
+            }
+            else if(zhangLocCor[0] < cor[0])
+            {
+                for(int row = zhangLocCor[0] + 1; row <= cor[0]; row++)
+                {
+                    if(isSameKingdom(kingdom, placement, corTochar(zhangLocCor[1], row)))
+                        boardMatrix[row][zhangLocCor[1]] = "";
+                }
+            }
+        }
+        boardMatrix[zhangLocCor[0]][zhangLocCor[1]] = "";
+        boardMatrix[cor[0]][cor[1]] = "z9";
+        return boardMatrix;
     }
 
     /**
@@ -79,12 +463,92 @@
      * @param numPlayers   the number of players in the game, must be in the range [2..4]
      * @param playerId     the player number for which to get the list of supporters, [0..(numPlayers-1)]
      * @return the list of supporters for the given player
+     * Arthor:Garrick Lin
      */
     public static String getSupporters(String setup, String moveSequence, int numPlayers, int playerId) {
         // FIXME Task 7: get the list of supporters for a given player after a sequence of moves
-        return null;
+        Player player = new Player(playerId);
+        int offset = numPlayers;
+        String placement = setup;
+        //transfer placment into 6*6 board matrix.
+        String boardMatrix[][] = new String[6][6];
+        boardMatrix = createMatrix(placement);
+        String str = new String();
+
+        for(int i = 0; i < moveSequence.length(); i++)
+        {
+            //assign i with corresponding location char
+            //for(int i=playerId; i<moveSequence.length();i+=numPlayers)
+            if(i % numPlayers == playerId)
+
+                player = oneMove(moveSequence.charAt(i),placement, boardMatrix, player);
+            //"oneMove" method from task06
+            boardMatrix = oneMove(moveSequence.charAt(i), placement, boardMatrix);
+            placement = matrixToString(boardMatrix);
+        }
+        player.sortKingdom();
+        player.sortSupporters();
+        return player.getSortedSupporters();
+    }
+
+    static Player oneMove(char charLocation, String placement, String[][] boardMatrix, Player player)
+    {
+        //finding zhang yi's next location and original location on board matrix
+        int cor[] = transformCor(charLocation);
+        char zhangLocChar = zLocation(placement);
+        int zhangLocCor[] = transformCor(zhangLocChar);
+
+        char kingdom = getKingdom(charLocation, placement);
+        if(!player.hasKingdom(kingdom))
+            player.addKingdom(kingdom);
+        if(zhangLocCor[0] == cor[0])
+        {
+            if(zhangLocCor[1] > cor[1])
+            {
+                for(int col = zhangLocCor[1] - 1; col >= cor[1]; col--)
+                {
+                    if(isSameKingdom(kingdom, placement, corTochar(col, zhangLocCor[0])))
+                        player.addSupporters(kingdom, boardMatrix[zhangLocCor[0]][col]);
+                        //boardMatrix[zhangLocCor[0]][col] = "";
+                }
+            }
+            else if(zhangLocCor[1] < cor[1])
+            {
+                for(int col = zhangLocCor[1] + 1; col <= cor[1]; col++)
+                {
+                    if(isSameKingdom(kingdom, placement, corTochar(col, zhangLocCor[0])))
+                        player.addSupporters(kingdom, boardMatrix[zhangLocCor[0]][col]);
+                        //boardMatrix[zhangLocCor[0]][col] = "";
+                }
+            }
+        }
+        else if(zhangLocCor[1] == cor[1])
+        {
+            if(zhangLocCor[0] > cor[0])
+            {
+                for(int row = zhangLocCor[0] - 1; row >= cor[0]; row--)
+                {
+                    if(isSameKingdom(kingdom, placement, corTochar(zhangLocCor[1], row)))
+                        player.addSupporters(kingdom, boardMatrix[row][zhangLocCor[1]]);
+                        //boardMatrix[row][zhangLocCor[1]] = "";
+                }
+            }
+            else if(zhangLocCor[0] < cor[0])
+            {
+                for(int row = zhangLocCor[0] + 1; row <= cor[0]; row++)
+                {
+                    if(isSameKingdom(kingdom, placement, corTochar(zhangLocCor[1], row)))
+                        player.addSupporters(kingdom, boardMatrix[row][zhangLocCor[1]]);
+                        //boardMatrix[row][zhangLocCor[1]] = "";
+                }
+            }
+        }
+        //boardMatrix[zhangLocCor[0]][zhangLocCor[1]] = "";
+        //boardMatrix[cor[0]][cor[1]] = "z9";
+        return player;
     }
 
+
     /**
      * Given a setup and move sequence, determine which player controls the flag of each kingdom
      * after all the moves in the sequence have been played.
@@ -101,10 +565,74 @@
      * - element 5 contains the player ID of the player who controls the flag of Wei
      * - element 6 contains the player ID of the player who controls the flag of Yan
      * If no player controls a particular house, the element for that house will have the value -1.
+     * Author:Garrick Lin
      */
     public static int[] getFlags(String setup, String moveSequence, int numPlayers) {
         // FIXME Task 8: determine which player controls the flag of each kingdom after a given sequence of moves
-        return null;
+        int flag[] = new int[7];
+        Player player[] = new Player[numPlayers];
+        char kingdoms[] = {'a', 'b', 'c', 'd', 'e', 'f', 'g'};
+        char deKingdom;
+        String boardMatrix[][] = new String[6][6];
+        boardMatrix = createMatrix(setup);
+        String placement = setup;
+        for(int i = 0; i < numPlayers; i++)
+            player[i] = new Player(i);
+        for(int i = 0; i < 7; i++)
+            flag[i] = -1;
+        for (int i = 0; i < moveSequence.length(); i++) {
+            //for each element in moveSequence, call oneMove method to let corresponding player who should
+            //carry out this move to collect card
+            //deKingdom is the kingdom in destination location
+            deKingdom = getKingdom(moveSequence.charAt(i), placement);
+            player[i % numPlayers] = oneMove(moveSequence.charAt(i), placement, boardMatrix, player[i % numPlayers]);
+            //change the boardMatrix according to this move
+            boardMatrix = oneMove(moveSequence.charAt(i), placement, boardMatrix);
+            placement = matrixToString(boardMatrix);
+            //(deKingdom - 97) corresponding to the slot in flag[] which hold the winner for this kingdom
+            //if this slot is empty, then, this player hold the flag after this move.
+            //if the the number of supporters for this kingdom this player hold is greater than the orignal holder
+            //for this kingdom, replace it
+            if (flag[(int) (deKingdom - 97)] == -1)
+            {
+                //System.out.println(moveSequence);
+                flag[(int) (deKingdom - 97)] = i % numPlayers;
+            }
+            else if (player[i % numPlayers].getNumSup(deKingdom) >= player[flag[(int) (deKingdom - 97)]].getNumSup(deKingdom))
+                flag[(int) (deKingdom - 97)] = i % numPlayers;
+        }
+        return flag;
+    }
+
+    public static String[] substr(String placement)
+    {
+        int count =0;
+        String sub[] = new String[placement.length()/3];
+        for (int x = 0; x < placement.length(); x += 3) {
+            sub[count] = placement.substring(x, x + 3);
+            count++;
+        }
+        return sub;
+    }
+
+
+    static Player getSupportersList(String setup, String moveSequence, int numPlayers, int playerId) {
+        Player player = new Player(playerId);
+        int offset = numPlayers;
+        String placement = setup;
+        String boardMatrix[][] = new String[6][6];
+        boardMatrix = createMatrix(placement);
+        String str = new String();
+        for(int i = 0; i < moveSequence.length(); i++)
+        {
+            if(i % numPlayers == playerId)
+                player = oneMove(moveSequence.charAt(i),placement, boardMatrix, player);
+            boardMatrix = oneMove(moveSequence.charAt(i), placement, boardMatrix);
+            placement = matrixToString(boardMatrix);
+        }
+        player.sortKingdom();
+        player.sortSupporters();
+        return player;
     }
 
     /**
@@ -120,9 +648,140 @@
      * If there is no legal move available, return the null character '\0'.
      * @param placement the current placement string
      * @return a location character representing Zhang Yi's destination for the move
+     * Arthor: Jiajia Xu
      */
     public static char generateMove(String placement) {
         // FIXME Task 10: generate a legal move
-        return '\0';
+        Random ran = new Random();
+        if(LegalMoves(placement).isEmpty()) {
+            return '\0';
+        }
+        else{
+            //if legal moves are not empty, genrate a random location char from legal moves
+            int index = ran.nextInt(LegalMoves(placement).size());
+            return LegalMoves(placement).get(index);
+            }
+    }
+
+    //Legal moves for zhang yi
+    public static List<Character> LegalMoves(String placement) {
+        List<Character> result = new ArrayList<Character>();
+
+        for(int i = 2; i < placement.length(); i += 3){
+            if(isMoveLegal(placement,placement.charAt(i))){
+                result.add(placement.charAt(i));
+            }
+        }
+
+        return result;
     }
+
+
+
+    public static int[][] getSupportersDetail(String setup, String moveSequence, int numPlayers)
+    {
+        int supporters[][] = new int[7][numPlayers];
+        for(int playerID = 0; playerID < numPlayers; playerID++)
+        {
+            String supportersStr = getSupporters(setup, moveSequence, numPlayers, playerID);
+            for(int i = 0; i < supportersStr.length(); i = i + 2)
+            {
+                String sub = supportersStr.substring(i, i + 2);
+                switch (sub.charAt(0))
+                {
+                    case 'a':
+                        supporters[0][playerID]++;
+                        break;
+                    case 'b':
+                        supporters[1][playerID]++;
+                        break;
+                    case 'c':
+                        supporters[2][playerID]++;
+                        break;
+                    case 'd':
+                        supporters[3][playerID]++;
+                        break;
+                    case 'e':
+                        supporters[4][playerID]++;
+                        break;
+                    case 'f':
+                        supporters[5][playerID]++;
+                        break;
+                    case 'g':
+                        supporters[6][playerID]++;
+                        break;
+                }
+
+            }
+        }
+        return supporters;
+    }
+
+    public static String[][] oneMoveGame(char charLocation, String placement, String[][] old_boardMatrix)
+    {
+        //change the board state according to current move char
+        //the parameter are follow:
+        //@charLocation: the destination location
+        //@placement: placement string
+        //boardMatrix: matrix represent current board state
+        //return a matrix that represent new board state after current move
+        String boardMatrix[][] = new String[6][6];
+        for(int i = 0; i < 6; i++)
+            for(int j = 0; j < 6; j++)
+                boardMatrix[i][j] = old_boardMatrix[i][j];
+        int cor[] = transformCor(charLocation);
+        char zhangLocChar = zLocation(placement);
+        int zhangLocCor[] = transformCor(zhangLocChar);
+        char kingdom = getKingdom(charLocation, placement);
+        if(zhangLocCor[0] == cor[0])
+        {
+            //if destination location is in the same row as ZhangYi's location
+            if(zhangLocCor[1] > cor[1])
+            {
+                for(int col = zhangLocCor[1] - 1; col >= cor[1]; col--)
+                {
+                    //start from ZhangYi's location to destination location
+                    //determine whether this location has the same kingdom as destination location
+                    if(isSameKingdom(kingdom, placement, corTochar(col, zhangLocCor[0])))
+                        boardMatrix[zhangLocCor[0]][col] = "";
+                }
+            }
+            else if(zhangLocCor[1] < cor[1])
+            {
+                for(int col = zhangLocCor[1] + 1; col <= cor[1]; col++)
+                {
+                    if(isSameKingdom(kingdom, placement, corTochar(col, zhangLocCor[0])))
+                        //if the kindome is same, set the element in this location to ""
+                        boardMatrix[zhangLocCor[0]][col] = "";
+                }
+            }
+        }
+        else if(zhangLocCor[1] == cor[1])
+        {
+            //if destination location is in the same column as ZhangYi's location
+            if(zhangLocCor[0] > cor[0])
+            {
+                for(int row = zhangLocCor[0] - 1; row >= cor[0]; row--)
+                {
+                    //start from ZhangYi's location to destination location
+                    //determine whether this location has the same kingdom as destination location
+                    if(isSameKingdom(kingdom, placement, corTochar(zhangLocCor[1], row)))
+                        //if the kindome is same, set the element in this location to ""
+                        boardMatrix[row][zhangLocCor[1]] = "";
+                }
+            }
+            else if(zhangLocCor[0] < cor[0])
+            {
+                for(int row = zhangLocCor[0] + 1; row <= cor[0]; row++)
+                {
+                    if(isSameKingdom(kingdom, placement, corTochar(zhangLocCor[1], row)))
+                        boardMatrix[row][zhangLocCor[1]] = "";
+                }
+            }
+        }
+        boardMatrix[zhangLocCor[0]][zhangLocCor[1]] = "";
+        boardMatrix[cor[0]][cor[1]] = "z9";
+        return boardMatrix;
+    }
+
 }
Only in comp1110-ass2/src: gittest
Only in comp1110-ass2/src: resource
Only in comp1110-ass2/tests/comp1110/ass2: corTocharTest.java
Only in comp1110-ass2/tests/comp1110/ass2: GetKingdomTest.java
Only in comp1110-ass2/tests/comp1110/ass2: isEmptyLocTest.java
Only in comp1110-ass2/tests/comp1110/ass2: isSameKingdomTest.java
Only in comp1110-ass2/tests/comp1110/ass2: SubstrTest.java
Only in comp1110-ass2/tests/comp1110/ass2: TransformCorTest.java
Only in comp1110-ass2/tests/comp1110/ass2: zlocationTest.java
```
## Test log
```
--javac output--
Note: comp1110-ass2/src/comp1110/ass2/gui/Game.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
----
java -cp comp1110-ass2/src:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/ass2-1110-tests.jar:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/hamcrest-core-1.3.jar:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/junit-4.12.jar:/usr/lib/jvm/oracle-java8-jdk-amd64/jre/lib/ext/jfxrt.jar org.junit.runner.JUnitCore comp1110.ass2.CardPlacementWellFormedTest
---
JUnit version 4.12
.....
Time: 0.016

OK (5 tests)

java -cp comp1110-ass2/src:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/ass2-1110-tests.jar:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/hamcrest-core-1.3.jar:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/junit-4.12.jar:/usr/lib/jvm/oracle-java8-jdk-amd64/jre/lib/ext/jfxrt.jar org.junit.runner.JUnitCore comp1110.ass2.PlacementWellFormedTest
---
JUnit version 4.12
.....
Time: 0.063

OK (5 tests)

java -cp comp1110-ass2/src:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/ass2-1110-tests.jar:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/hamcrest-core-1.3.jar:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/junit-4.12.jar:/usr/lib/jvm/oracle-java8-jdk-amd64/jre/lib/ext/jfxrt.jar org.junit.runner.JUnitCore comp1110.ass2.MoveLegalTest
---
JUnit version 4.12
.....
Time: 0.025

OK (5 tests)

java -cp comp1110-ass2/src:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/ass2-1110-tests.jar:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/hamcrest-core-1.3.jar:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/junit-4.12.jar:/usr/lib/jvm/oracle-java8-jdk-amd64/jre/lib/ext/jfxrt.jar org.junit.runner.JUnitCore comp1110.ass2.MoveSequenceValidTest
---
JUnit version 4.12
.....
Time: 0.066

OK (5 tests)

java -cp comp1110-ass2/src:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/ass2-1110-tests.jar:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/hamcrest-core-1.3.jar:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/junit-4.12.jar:/usr/lib/jvm/oracle-java8-jdk-amd64/jre/lib/ext/jfxrt.jar org.junit.runner.JUnitCore comp1110.ass2.GetSupportersTest
---
JUnit version 4.12
...
Time: 0.129

OK (3 tests)

java -cp comp1110-ass2/src:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/ass2-1110-tests.jar:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/hamcrest-core-1.3.jar:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/junit-4.12.jar:/usr/lib/jvm/oracle-java8-jdk-amd64/jre/lib/ext/jfxrt.jar org.junit.runner.JUnitCore comp1110.ass2.GetFlagsTest
---
JUnit version 4.12
...
Time: 0.073

OK (3 tests)

java -cp comp1110-ass2/src:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/ass2-1110-tests.jar:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/hamcrest-core-1.3.jar:/students/u3179443/comp1110/comp1110-tutors/bin/../ass2/junit-4.12.jar:/usr/lib/jvm/oracle-java8-jdk-amd64/jre/lib/ext/jfxrt.jar org.junit.runner.JUnitCore comp1110.ass2.GenerateMoveTest
---
JUnit version 4.12
...
Time: 0.017

OK (3 tests)

```
